sick -> email sci 1

same charge -> higher proton -> smaller radius

Effective Nuclear Charge = Atomic number - Screening constant

shielding constant -> screening constant

homology -> similarity due to shared ancestry
morphology -> finding similarity by strucure



FFMFFMFFmffmfmfffmfffmmffmmfmmfffmmfmmfffmfmffmmfmffm < 

"Women answer less questions"-rosie
well lets test that theory







"self sustaining chemical system capable of darwinian evolution"





you know how its a pain in the ass to find some shit in canvas
and ctrl+f doesnt usually work cuz in another webpage
i can make a ctrl+f work for multiple web pages and also give u the link








var a; var b

let l = document.links
let r = []

function myFind(){
	for(let i = 0; i < l.length; i++){
		GetWeb(l[i].href,i)
	}
}

function mySearch(wrd){
	r.forEach((e,i)=>{
		let ind = e.indexOf(wrd)
		if(ind == -1){return}
		console.log(l[i].text+" found at "+ind)
	})
}


function GetWeb(link,i){
	fetch(link).then(res=>{return(res.text())}).then(txt=>{r[i] = txt})
}


fetch("https://canvas.ubc.ca/courses/155723").then(response=>{return(response.text())}).then(text=>{console.log(text); a = text})







Q
why doesnt an electron just fall into the proton
are tails limbs?
What counts as a limb

TD
Video
Achieve chem
Eng tempest (mon)
Lab coat n stuff	























Analytical vs eulers method:



The equation for analytical method will always produce a perfect result for what you ask it to do
But you are asking it to do the wrong thing

I dont know the analytical equation for with drag


yes. It is much easier to model anything with eulers model, and much harder for analytical equations
But eulers is always wrong by a bit

























Analytical is always perfect
eulers is an estimate of analytical


BUT

they have to be modeling the same thing

In this case, the analytical is producing "The perfect graph for no drag"
and the eulers is producing "Not so perfect graph WITH drag"

so eulers method is more accurate to real life because there is drag
But analytical is PERFECT at what it does, 


Also, if you knew the ANALYTICAL equation with drag, it will be better than euler method with drag



Here is an analogy i guess

An Atom clock is more accurate than a mechanical clock

But, an atom clock can be more wrong than a mechanical clock if you put in some situations
Like flying really fast










//sqript3


rule of thumb: Change the base activators of whatever you want to actually change


nodes have a set of connected switches as input
nodes can do logic on the set of input
after doing logic, the node should have 1 switch as output


if any node switch is changed, it should back propegate the information
Any back propegated node switch should also back propegate

keep a backpropegation list of switches that has been processed

When backpropegating, if the same switch is being processed again, there is a collision
if the collision results in different states, the logic is wrong and everything should be reverted.


for any switch that was changed, propegate the information


keep a propegation list of switches that has been processed

When propegating, if the same switch is being processed again, there is a collision
if the collision results in different states, the logic is wrong and everything should be reverted.



Nodes can be forced to read switches to produce an output
   if the output is different, propegate




Experimental:
No chiral chains allowed
children chain


Every node should store all its subchildren in a dict
Nodes can only be processed when none of their subchildren are done


Experimental 2:
every node switch should have an UUID higher than all of its children



























































let div = document.createElement("div")
div.innerText=`> a
> b
> c
| a | b | test
| a | b | stest2
@ a @@ nota
@ a @ linka
| nota | linka | notlink
`
div.style.backgroundColor = "black"
div.style.color = "lime"
div.contentEditable=true


let button = document.createElement("button")
button.innerText = "load"
button.onclick=()=>{load();console.log('loaded')}
document.body.appendChild(div)
  document.body.appendChild(button)
 button = document.createElement("button")
button.innerText = "tick"
button.onclick=()=>{tick()}
  document.body.appendChild(button)

 button = document.createElement("button")
button.innerText = "step"
button.onclick=()=>{step()}
  document.body.appendChild(button)

var canvas;
function setup() {
  createCanvas(800, 200);
  // noCanvas()
  // canvas = document.getElementById("defaultCanvas0")
  
}

let pressed = false

function draw() {
  background(220);
  let objk = Object.keys(BITMAP)
  objk.forEach((e,i)=>{
    i+=1
    fill(BITMAP[e].state?"green":"red")
    text(e,i*50,30)
    text( (BITMAP[e].activation+"").substring(6,Infinity),i*50,20)
    
    
    circle(i*50+5,40,10)
  })
  let item = Math.floor((mouseX+20)/50)
  rect(item*50,50,20,20)
  item -=1
  if(mouseIsPressed){
    if(pressed == false){
      if(mouseY < 200 && BITMAP[objk[item]]){
        // setState(objk[item],!BITMAP[objk[item]].state)
        manualStateChange(objk[item])
      }
    }
    pressed = true
  } else {pressed=false}
}

let BITMAP = {}

function setState(k,value){
  // if(BITMAP[k].prop){BITMAP[k].prop.forEach((e)=>{e.activate()})}
  if(BITMAP[k].state!==undefined){if(BITMAP[k].state==value){return};
    // if(BITMAP[k].owner){BITMAP[k].owner.backProp(true);return}                                                         
    BITMAP[k].state = value}else{
    BITMAP[k] = {"state":value}
  }
  
}

let uuid = 1
function registerBit(name,hard){
  if(name){
    if(hard){if(BITMAP[name]){return(false)}}
    let aname = name
    let i = 1
    while(BITMAP[aname]){
      aname = name+i
      i++
    }
    
    BITMAP[aname]={"state":false}
    return(aname)
  }
  while(BITMAP[uuid]){uuid++}
  BITMAP[uuid]={"state":false}
  return(uuid)
}

class logicNode{
  constructor(KEY){
    this.input = []
    // this.output = {}
    this.outputKey = KEY?registerBit(KEY):registerBit(); //map key
    this.activity = Date.now()
    this.lastInput = []
    this.lastlastInput = []
    this.lastDifferentInput = []
    this.relay = {}
    
    BITMAP[this.outputKey].owner = this
  }
  
  setInput(arr){
    this.input=arr
    arr.forEach((e)=>{
      if(BITMAP[e] == undefined){registerBit(e)}
      if(BITMAP[e].prop===undefined){BITMAP[e].prop=[]}
      BITMAP[e].prop.push(this)
    })
  }
  
  getInputs(){
    let outarr = []
    let different=false
    this.input.forEach((e,i)=>{
      outarr[i] = BITMAP[e].state
      if(outarr[i] !== this.lastInput[i]){different=true}
    })
    if(different){
      this.lastlastInput = this.lastInput
      this.lastInput = outarr
    }

    return(outarr)
  }
  
  
  activate(activation=Date.now()){
    if(this.activity == activation){console.log(this.outputKey+" was already activated");return}
    this.activity = activation
    let arr = this.getInputs()
    let result = this.func(arr)
    // setState(this.outputKey,result)
    if(result !== BITMAP[this.outputKey].state){
      // console.log("prev:"+BITMAP[this.outputKey].state+"now:"+result)
      // console.log(JSON.stringify(this.lastlastInput),JSON.stringify(this.lastInput))
      this.lastDifferentInput = this.lastlastInput
      newStateChanges.push(this.outputKey)
    }
    // setState(this.outputKey,result)
    BITMAP[this.outputKey].activation = activation
    console.log(this.outputKey + " is set to "+ result)
    return(result)
  }
  func(arr){
    
  }
  
  backProp(revert,activation=Date.now()){
    
    // if(this.activity == activation){return}
    // this.activity = activation
    
    if(this.back){
      let arr = this.back(revert)
      console.log(arr)
      arr.forEach((e)=>{
        // if(BITMAP[e].owner){
        //   BITMAP[e].owner.backProp(revert)
        // } else {
          // BITMAP[e].state = !BITMAP[e].state
        
        
        BITMAP[e].activation = activation
          newStateChanges.push(e)
          propPending.push(e)
        // }
      })
    }
    // BITMAP[this.outputKey].state = !BITMAP[this.outputKey].state
          // newStateChanges.push(this.outputKey)
    let thisInput = this.lastDifferentInput
    // console.log(JSON.stringify(this.lastlastInput))
    this.lastlastInput = this.lastInput
    this.lastDifferentInput = this.lastInput
    console.log(JSON.stringify(this.lastInput),JSON.stringify(thisInput))
    this.lastInput = thisInput
  }
}

//logic nodes should have multiple inputs


//there is a master BIT map
//base OR node will activate, retrieve inputs, create an output



//the premise is: Computers work, but somewhere they work redundantly.


//backprop of "or"
//Turned from False to True:
//11 -> revert both
//10 -> (inverse/not inverse)
//01 -> (inverse/not inverse)
//Turned from true to false: (inverse/not inverse)


  
function trimSpace(str){
  while(str[0] == " "){
    str = str.substring(1)
  }
  while(str[str.length-1]==" "){
    str = str.substring(0, str.length - 1);
  }
  return(str)
}

  
function newANDnode(ins,KEY){
  let ANDnode = new logicNode(KEY)
ANDnode.func = (arr)=>{if(arr[0] && arr[1]){return(true)}return(false)}
ANDnode.back = (revert)=>{
  let back = []
  if(revert){
    // if(BITMAP[ORnode.outputKey].state){
      if(ANDnode.lastInput[0] != ANDnode.lastDifferentInput[0]){
        back.push(ANDnode.input[0])
      }
      if(ANDnode.lastInput[1] != ANDnode.lastDifferentInput[1]){
        back.push(ANDnode.input[1])
      }

  }
  return(back)
  }
  if(ins){
    ANDnode.setInput(ins)
  }
  ANDnode.lastInput = [false,false]
  ANDnode.lastlastInput = [false,false]
  ANDnode.lastDifferentInput = [true,true]
return(ANDnode)
}

function newLINKnode(ins,KEY){
  let LINKnode = new logicNode(KEY)
LINKnode.func = (arr)=>{if(arr[0]){return(true)}return(false)}
LINKnode.back = (revert)=>{
  let back = []
  if(revert){
    // if(BITMAP[ORnode.outputKey].state){
      if(LINKnode.lastInput[0] != LINKnode.lastDifferentInput[0]){
        back.push(LINKnode.input[0])
      }

  }
  return(back)
  }
  if(ins){
    LINKnode.setInput(ins)
  }
  LINKnode.lastInput = [false]
  LINKnode.lastlastInput = [false]
  LINKnode.lastDifferentInput = [true]
return(LINKnode)
}
  
  
  function newNOTnode(ins,KEY){
  let NOTnode = new logicNode(KEY)
NOTnode.func = (arr)=>{if(arr[0]){return(false)}return(true)}
NOTnode.back = (revert)=>{
  let back = []
  if(revert){
    // if(BITMAP[ORnode.outputKey].state){
      if(NOTnode.lastInput[0] != NOTnode.lastDifferentInput[0]){
        back.push(NOTnode.input[0])
      }

  }
  return(back)
  }
  if(ins){
    NOTnode.setInput(ins)
  }
  NOTnode.lastInput = [false]
  NOTnode.lastlastInput = [false]
  NOTnode.lastDifferentInput = [true]
return(NOTnode)
}

function newORnode(ins,KEY){
  let ORnode = new logicNode(KEY)
ORnode.func = (arr)=>{if(arr[0] || arr[1]){return(true)}return(false)}
ORnode.back = (revert)=>{
  let back = []
  if(revert){
    // if(BITMAP[ORnode.outputKey].state){
      if(ORnode.lastInput[0] != ORnode.lastDifferentInput[0]){
        back.push(ORnode.input[0])
      }
      if(ORnode.lastInput[1] != ORnode.lastDifferentInput[1]){
        back.push(ORnode.input[1])
      }

  }
  return(back)
  }
  if(ins){
    ORnode.setInput(ins)
  }
  ORnode.lastInput = [false,false]
  ORnode.lastlastInput = [false,false]
  ORnode.lastDifferentInput = [true,true]
return(ORnode)
}

function manualStateChange(k){
  // BITMAP[k].state = !BITMAP[k].state
  newStateChanges.push(k)
  propPending.push(k)
  BITMAP[k].activation = Date.now()
}                                  
var stateChanges = []                                
var newStateChanges = [] 
var propPending = [] 
var mode = "back"
function tick(){
  // console.log("ticking: "+JSON.stringify(newStateChanges))
  stateChanges=newStateChanges
  newStateChanges=[]
  stateChanges.forEach((e)=>{
    BITMAP[e].state = !BITMAP[e].state
  })
  
  //mode == back prop
  if(mode == "back"){
  stateChanges.forEach((e)=>{
    if(BITMAP[e].owner){
      BITMAP[e].owner.backProp(true,BITMAP[e].activation)
    }
  })}
  //mode == propegation
  if(mode == "prop"){
    stateChanges.forEach((e)=>{
    if(BITMAP[e].prop){
      BITMAP[e].prop.forEach((E)=>{E.activate(BITMAP[e].activation)})
    }
  })
  }
  
  if(newStateChanges.length == 0){
    if(mode == "back"){
      mode = "prop" 
      console.log("propegating: "+JSON.stringify(propPending))
      newStateChanges = propPending
      newStateChanges.forEach((e)=>{
        BITMAP[e].state = !BITMAP[e].state
      })
    } else {
      mode = "back"
      propPending = []
      console.log("step complete")
      return(true)
    }
  }
  
}                
function step(){
  let res = false
  while(!res){
        res = tick()
        }
}
                       
  
  function load(){
  BITMAP = []
  let str = div.innerText
  let lines = str.split("\n")
  lines.forEach((e)=>{
    if(e[0] == ">"){
      let item = e.substring(1)
      while(item[0]==" "){item=item.substring(1)}
      console.log("bit > "+item)
      let register = registerBit(item.split(" ")[0],true)
      if(register ===false){console.log("failed to register already existing: "+item)}
    } else if(e[0] == "!"){
      // let item = e.substring(1)
      // while(item[0]==" "){item=item.substring(1)}
      // console.log("relay > "+item)
    } else if(e[0] == "|"){
      let items = e.substring(1).split("|")
      if(items.length==3){
        let name = trimSpace(items[2])
        if(BITMAP[name]){
          console.log("already registerd failure")
        } else {
          let n = newORnode([trimSpace(items[0]),trimSpace(items[1])],name)
        }
      
      } else if(items.length == 1){
      let n = newORnode(undefined,trimSpace(items[0]))
      }
    } else if(e[0] == "&"){
      let items = e.substring(1).split("&")
      if(items.length==3){
        let name = trimSpace(items[2])
        if(BITMAP[name]){
          console.log("already registerd failure")
        } else {
          let n = newANDnode([trimSpace(items[0]),trimSpace(items[1])],name)
        }
      
      } else if(items.length == 1){
      let n = newANDnode(undefined,trimSpace(items[0]))
      }
    } else if(e[0] == "/"){ //set input of undefined node
      let items = e.substring(1).split("/")
      if(items.length==3){
        let name = trimSpace(items[2])
        if(BITMAP[name]){
          if(BITMAP[name].owner){
            BITMAP[name].owner.setInput([trimSpace(items[0]),trimSpace(items[1])])
          } else {
            console.log("no owner")
          }
        } else {
          console.log("not registered")
        }
      
      } else if(items.length == 1){
      let n = newANDnode(undefined,trimSpace(items[0]))
      }
    } else if(e[0] == "@"){
      let items = e.substring(1).split("@")
      if(items.length == 2){ //link
          let n = newLINKnode([trimSpace(items[0])],trimSpace(items[1]))
        
      } else if(items.length == 3){ // not
          let n = newNOTnode([trimSpace(items[0])],trimSpace(items[2]))
        
      }
    }
  })
}
  
  
var ORnode = newORnode(["a","b"])

// registerBit("test")
// registerBit("test2")
// ORnode.setInput(["test","test2"])
  
newANDnode([1,"c"])
// setState("test",true)
// ORnode.activate()
// setState("test",false)
// ORnode.activate()
// setState("test",true)
// setState("test2",true)
// ORnode.activate()
// ORnode.activate()







































