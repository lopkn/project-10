<!DOCTYPE html>
<html>
  <meta charset="UTF-8" />
  <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />

  <style>
    html,
      body {
        margin: 0;
        padding: 0;
      }

    #debug {
      position: absolute;
      top:0;
      left:0;
      color: #ff9999;
    }

  </style>
  <body>

    <div id="debug"></div>




     <script id="vertexShader" type="x-shader/x-vertex">
        precision highp float;

        uniform float sineTime;

        uniform vec3 cameraPos;

        uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;

        attribute vec3 position;
        attribute vec3 offset;
        attribute vec4 color;
        attribute vec4 orientation;

        varying vec3 vPosition;
        varying vec4 vColor;

        vec3 quat_transform(vec4 q, vec3 v) {
          return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
        }

    void main(){

      float size = 5000.0;
      vPosition = offset;
      vPosition.x += floor((cameraPos.x-vPosition.x)/size + 0.5)*size;
      vPosition.y += floor((cameraPos.y-vPosition.y)/size + 0.5)*size;
      vPosition.z += floor((cameraPos.z-vPosition.z)/size + 0.5)*size;

      vPosition = vPosition + quat_transform(orientation,position);
      vec3 vcV = cross( orientation.xyz, vPosition );


      vColor = color;

      gl_Position = projectionMatrix * modelViewMatrix * vec4( vPosition, 1.0 );

    }

  </script>

  <script id="fragmentShader" type="x-shader/x-fragment">

    precision highp float;
    uniform float sineTime;

    varying vec3 vPosition;
    varying vec4 vColor;

    void main() {

      vec4 color = vec4( vColor );
      color.r = sineTime;

      gl_FragColor = color;

    }

  </script>
















     <script id="vertexShader2" type="x-shader/x-vertex">
        precision highp float;

        uniform float sineTime;
        uniform float time;

        uniform vec3 cameraPos;

        uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;

        attribute vec3 position;
        attribute vec3 offset;
        attribute vec4 color;
        attribute vec4 orientationStart;
        attribute vec4 rotationDelta;

        varying vec3 vPosition;
        varying vec4 vColor;

        vec3 quat_transform(vec4 q, vec3 v) {
          return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
        }

        vec4 multiplyQuaternions(vec4 q1, vec4 q2) {
          return vec4(
              q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
              q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
              q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,
              q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z
          );
      }

      vec4 rotateQuatByDelta(vec4 Ccurrent, vec4 qDelta, float rotationPercentage) {
          qDelta = normalize(qDelta);

          float angle = acos(qDelta.w) * 2.0; // rotation angle from quaternion
          float scaledAngle = angle * rotationPercentage; // scale by the percentage

          vec4 qScaled;
          qScaled.w = cos(scaledAngle / 2.0);
          qScaled.xyz = sin(scaledAngle / 2.0) * normalize(qDelta.xyz);

          vec3 rotatedVector = Ccurrent.xyz * (2.0 * dot(qScaled.xyz, Ccurrent.xyz) * qScaled.xyz 
                           + (qScaled.w * qScaled.w - dot(qScaled.xyz, qScaled.xyz)) * Ccurrent.xyz 
                           + 2.0 * qScaled.w * cross(qScaled.xyz, Ccurrent.xyz));

          return vec4(rotatedVector, Ccurrent.w); // Return rotated vector with original w component
      }

    void main(){

      float size = 5000.0;
      vPosition = offset;

      vec4 orientation = normalize( rotateQuatByDelta( orientationStart, rotationDelta, time ));
      vPosition = vPosition + quat_transform(orientation,position);
      vec3 vcV = cross( orientation.xyz, vPosition );


      vColor = color;

      gl_Position = projectionMatrix * modelViewMatrix * vec4( vPosition, 1.0 );

    }

  </script>

  <script id="fragmentShader2" type="x-shader/x-fragment">

    precision highp float;
    uniform float time;

    varying vec3 vPosition;
    varying vec4 vColor;

    void main() {

      vec4 color = vec4( vColor );
      color.r = time;

      gl_FragColor = color;

    }

  </script>




























    <script type="importmap">
        {
        "imports": {
            "three": "../../../node_modules/three/build/three.module.js",
            "three/examples/jsm/shaders/CopyShader.js": "../../../node_modules/three/examples/jsm/shaders/CopyShader.js",
            "three/examples/jsm/postprocessing/EffectComposer.js": "../../../node_modules/three/examples/jsm/postprocessing/EffectComposer.js",
            "three/examples/jsm/postprocessing/RenderPass.js": "../../../node_modules/three/examples/jsm/postprocessing/RenderPass.js",
            "three/examples/jsm/postprocessing/ShaderPass.js": "../../../node_modules/three/examples/jsm/postprocessing/ShaderPass.js",
            "three/examples/jsm/postprocessing/OutlinePass.js": "../../../node_modules/three/examples/jsm/postprocessing/OutlinePass.js",
            "three/examples/jsm/postprocessing/OutputPass.js": "../../../node_modules/three/examples/jsm/postprocessing/OutputPass.js",
            "three/examples/jsm/shaders/FXAAShader.js":"../../../node_modules/three/examples/jsm/shaders/FXAAShader.js",
            "three/examples/jsm/loaders/GLTFLoader.js":"../../../node_modules/three/examples/jsm/loaders/GLTFLoader.js",


            "three/addons/": "../../../node_modules/three/examples/jsm/",

            "three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.9.0/build/index.module.js",

            "@three.ez/instanced-mesh": "https://cdn.jsdelivr.net/npm/@three.ez/instanced-mesh/build/index.js",
            "bvh.js": "https://cdn.jsdelivr.net/npm/bvh.js/build/index.js",

            "@three.ez/simplify-geometry": "https://cdn.jsdelivr.net/npm/@three.ez/simplify-geometry@0.0.1/build/index.js",
            "meshoptimizer": "https://cdn.jsdelivr.net/npm/meshoptimizer@0.23.0/+esm"
        }
    }
    </script>


    <script type="module">

        import * as THREE from 'three';
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
        import { OutlinePass } from 'three/examples/jsm/postprocessing/OutlinePass.js';
        import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';
        import { FXAAShader } from 'three/examples/jsm/shaders/FXAAShader.js';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { Line2 } from '../../../node_modules/three/examples/jsm/lines/Line2.js';
        import { LineGeometry } from '../../../node_modules/three/examples/jsm/lines/LineGeometry.js';
        // import { GeometryUtils } from '../../../node_modules/three/examples/jsm/utils/GeometryUtils.js';
        import { LineMaterial } from '../../../node_modules/three/examples/jsm/lines/LineMaterial.js';
        import { LineSegments2 } from '../../../node_modules/three/examples/jsm/lines/LineSegments2.js';
        import { LineSegmentsGeometry } from '../../../node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js';
        import { acceleratedRaycast, computeBatchedBoundsTree } from 'three-mesh-bvh';

        import { InstancedMesh2 } from '@three.ez/instanced-mesh';
        import { createRadixSort} from '@three.ez/instanced-mesh';

      const clock = new THREE.Clock();
      const scene = new THREE.Scene();

      var foggy = 0
      var downs = {}

let Width = window.innerWidth
let Height = window.innerHeight
let mouseX = Width/2
let mouseY = Height/2








      const camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.01,
        999999
      );
      camera.position.set(0, 60, 150);
      camera.lookAt(0,0,0)

    
      function instance(count,mov=()=>{},geometry = new THREE.BoxGeometry(1, 1, 1)){

          var materials = new THREE.MeshStandardMaterial({ color: "#FFFFFF"/*, roughness:0, metalness: 0.8*/})

          // geometry.computeVertexNormals() // delete if not found useful

          let mesh = new InstancedMesh2( geometry, materials, count );
          mesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // will be updated every frame
          scene.add(mesh);
          mesh.addInstances(count);

          let dummy = new THREE.Object3D()
          for ( let i = 0; i < count; i ++) {
              mov(dummy,i)
              dummy.updateMatrix();
              mesh.setMatrixAt( i, dummy.matrix );
          }
          return(mesh)
      }

      function addLight(x,objectPos){
        let l = new THREE.PointLight(0xffee50,2*(Math.random()*0.4+0.4)*x/50,8)
        l.position.copy(objectPos);
        scene.add(l)
      }


      class LCanvas{ //lopkns template canvas
        constructor(w=100,h=100,id=("LCanvas-"+Math.random())){
          this.canvas = document.createElement("canvas")
          this.canvas.id = id
          this.ctx = this.canvas.getContext("2d")
          this.canvas.style.position = "absolute"
          this.canvas.style.top = "0px"
          this.canvas.style.left = "0px"
          this.canvas.zIndex = "1500"
          this.canvas.width = w
          this.canvas.height = h
          this.ctx.fillStyle = "black"
          this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height)
          document.body.appendChild(this.canvas)
          return(this)
        }

        fitScreenSize(){
          this.canvas.width = window.innerWidth
          this.canvas.height = window.innerHeight
        }

        clear(){
          this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)
        }

        oneTimeDown(f){ // pass in a function for what to do with one click
          this.canvas.addEventListener("mousedown",f,{once:true})
        }

        getPixelRGB(x,y){
          let d = this.ctx.getImageData(x, y, 1, 1).data
          return(d)
        }


      }


      var canvas = new LCanvas(Width,Height)
      var ctx = canvas.ctx





















      // RENDERER
      const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
      renderer.shadowMap.enabled = true;
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(foggy);
      window.addEventListener("resize", onWindowResize);
      document.body.appendChild(renderer.domElement);

      // CONTROLS
      // const controls = new THREE.OrbitControls(camera, renderer.domElement);
      // controls.minDistance = 2;
      // controls.maxDistance = 20;
      // controls.update();



      var debugData = {}

      function dbg(val,str){
        debugData[val] = str
        return(str)
      }

      var particles = []

      function galacticAngle(xji,yji,zji,xjf,yjf,zjf,a,b,c,x,y,z){
        let fatChunk = ( a*(x-xji)+b*(y-yji)+c*(z-zji) )/(a**2+b**2+c**2)
        let chunky = (xjf-xji)*(x-a*fatChunk)+(yjf-yji)*(y-a*fatChunk)+(zjf-zji)*(z-a*fatChunk)
        let allOver = Math.sqrt((xjf-xji)**2+(yjf-yji)**2+(zjf-zji)**2) * Math.sqrt((x-a*fatChunk)**2+(y-a*fatChunk)**2+(z-a*fatChunk)**2)
        return(Math.acos(chunky/allOver))
      }


      class AIPID{

        constructor(drone,d=0,v=0){
          this.dFactor = d
          this.drone = drone
          this.velFactor = v

          this.lastPitch = 0
        }


        //when the error got bigger:
        // 

        calcPitch(){
          let AP = this.drone.target.clone().sub(this.drone.obj.position)
          let dd = AP.dot(this.drone.rightVec)
          this.drone.projPoint = this.drone.target.clone().sub(this.drone.rightVec.clone().multiplyScalar(dd))
          this.drone.projPitchAng = this.drone.dir.clone().angleTo(this.drone.projPoint.clone().sub(this.drone.obj.position))

          this.drone.projPitchAng2 = galacticAngle(...this.drone.obj.position.toArray(),...this.drone.dir.toArray(),...this.drone.rightVec.toArray(),...this.drone.target.toArray())


          // let d = this.drone.controls.pitch*(x?1:-1)
          this.dPitch = this.lastPitch - this.drone.projPitchAng
          this.lastPitch = this.drone.projPitchAng
        }

        predictPitch(x,dt){

          // projected point

          this.result = (this.drone.projPitchAng-this.dPitch/dt*(this.dFactor+this.velFactor* (this.drone.pitchMulter()-0.1) ))>0
          return(!x^this.result)
        }

        overshoot(){
          this.dFactor += 0.01
        }
        undershoot(){
          this.dFactor -= 0.02
        }

      }


      var weapons = {
        "hold fire":{"reload":Infinity},
        "spray":{"reload":0,"scatter":0.1,"AIcone":0.2,"direction":(x)=>{return(x.dir)}},
        "railgun":{"reload":300,"scatter":0.02,"AIcone":0.1,"direction":(x)=>{return(x.targetVect.clone().normalize().negate())}},
      }




      var AIs = { // target
        "v1":(x,dt)=>{


          // x.target = new THREE.Vector3(0,-2000,2000)


          x.AIdowns[" "]=true

          if(x.hunting){
            x.target = x.hunting.obj.position.clone()
          }

          x.targetVect = x.obj.position.clone().sub(x.target)
          // x.targRollAng = x.up.clone().dot(x.targetDir)
          x.targetDir = x.targetVect.clone().normalize()
          x.targDist = x.targetVect.length()
          // x.lastTargAng = x.targAng
          x.targAng = x.dir.clone().dot(x.targetDir) // -1 means perfectly pointed towards target

          x.rightVec = new THREE.Vector3(1, 0, 0).applyQuaternion(x.obj.quaternion)
          x.upVec = new THREE.Vector3(0, 1, 0).applyQuaternion(x.obj.quaternion)
          x.targRollAng = x.rightVec.clone().dot(x.targetDir)
          x.targPitchAng = x.upVec.clone().dot(x.targetDir) // 0 means perpendicular, -1 means head pointed toward target
          x.pitchDir = !(x.targPitchAng>0) // true = we want to go up

          if(Math.random()>0.5){
            x.targetBlock.position.copy(x.target)
          } else {
            x.targetBlock.position.copy(x.projPoint)
          }

          // PITCH logic (on same plane)

            dbg("pitch ang",x.targPitchAng)
            dbg("target ang",x.targAng)
            dbg("target dist",x.targDist)
            dbg("turn",x.turnDist)
            dbg("pitch dir",x.pitchDir)
          // console.log(x.turnDist === window.world.cameraDrone.turnDist)


            x.AIPID.calcPitch()


          if(dbg("far",x.targDist > x.turnDist)){

            if(x.targAng > -0.6){ // if not pointed near target
              x.up(x.pitchDir)
            } else {
              x.AIdowns.w = x.AIdowns.s = false
            }

            x.up(x.AIPID.predictPitch(x.pitchDir,dt))
          } else {
              x.AIdowns.w = x.AIdowns.s = false
            }


           if(dbg("precise",x.targAng < -0.6)){ // pointed near target, precise manuvers needed
              if(x.targAng < -1+weapons[x.weapon].AIcone){
                x.fire()
              }
              x.AIdowns.w = x.AIdowns.s = false
              if(x.controls.pitch>0.1 && x.pitchDir){
                x.up(!x.pitchDir)
              } else if(x.controls.pitch < -0.1 && !x.pitchDir){
                x.up(!x.pitchDir)
              } else {
                x.up(x.pitchDir)
              }
            x.up(x.AIPID.predictPitch(x.pitchDir,dt))

            }

          // ROLL logic

          if(Math.abs(x.targRollAng)>0.0001){

            if(x.targRollAng > 0){
              x.right(!x.pitchDir)
            } else {
              x.right(x.pitchDir)
            }

          } else {
            x.AIdowns.a = x.AIdowns.d = false
          }


          //panic
          if(x.paniced){
              x.AIdowns[" "] = false
            }

          dbg("PITCH UP",x.AIdowns.w)
          dbg("PITCH DOWN",x.AIdowns.s)
          dbg("ROLL RIGHT",x.AIdowns.d)
          dbg("ROLL LEFT",x.AIdowns.a)
          dbg("ACCELERATE",x.AIdowns[" "])

          if(x.AIdowns.w){
            x.tail.setColorAt((x.tailCounter)%x.tailLength,new THREE.Color(0xff0000))
          } else if(x.AIdowns.s){
            x.tail.setColorAt((x.tailCounter)%x.tailLength,new THREE.Color(0x00ff00))
          } else {
            x.tail.setColorAt((x.tailCounter)%x.tailLength,new THREE.Color(0xffffff))
          }


          if(!x.AIpassive){
            x.downs.w = x.AIdowns.w
            x.downs.s = x.AIdowns.s
            
            x.downs.a = x.AIdowns.a
            x.downs.d = x.AIdowns.d
            x.downs[" "] = x.AIdowns[" "]
          }


        }
      }


      // PITCHER:

      // predictors: up velocity, current pitch angle

      // current state: not failed

      // delta angle recorded each frame,

      // if angle overshoots
      //   while holding UP: overshoot
      // else: undershoot




      // [0 speed, !0 error: toward]








      function outterObjectS(objectGeom, objectColor, objectPos) {
        const objectMat = new THREE.MeshStandardMaterial({ color: objectColor });
        const object = new THREE.Mesh(objectGeom, objectMat);
        object.position.copy(objectPos);
        scene.add(object);
        return(object)
      }

          let lineyMat = new LineMaterial( {
            color: 0xffffff,
            linewidth: 5, // in world units with size attenuation, pixels otherwise
            vertexColors: true,
            dashed: false,
            alphaToCoverage: false,
            worldUnits: true
          } );

      class liney{
        constructor(arr,col=[0,1,1]){
          this.pos = arr
          this.life = 100
          let geometry = new LineGeometry();
          geometry.setPositions( new Float32Array(this.pos) );
          geometry.setColors([1,1,1,...col]);
          // geometry.computeBoundingSphere()
          // geometry.boundingSphere.radius = Infinity



          
          let line = new Line2( geometry, lineyMat );
          line.frustumCulled = false
          line.geometry.boundingSphere.radius = Infinity
          line.computeLineDistances()
          scene.add( line );
          particles.push(this)

          setTimeout(()=>{
            scene.remove(line)
            line.geometry.dispose()
          },200)


        }

        update(dt){
          this.life -= dt
          if(this.life <= 0 ){

          }
        }
      }


      class fighter{
        constructor(){
          this.obj = new THREE.Object3D()
          this.vel = 0
          this.obj.position.set(0,0,0);
          this.dir = new THREE.Vector3(0,0,1)
          this.controlSpeed = 0.1


          this.shotColor = [0,1,1]

          this.tailLength = 3000
          this.tailCounter = 0;
          this.tail = instance(this.tailLength,undefined,new THREE.BoxGeometry(80, 0.1, 10))
          this.tail.frustumCulled = false
          this.raycaster = new THREE.Raycaster()


          this.downs = {}

          this.reload = Date.now()
          this.weapon = "hold fire"


            this.controls = {
              "up":0,
              "pitch":0,
              "roll":0,
              "yaw":0
            }

            this.forces = {
              "up":0,
              "pitch":0,
              "roll":0,
              "yaw":0
            }
            scene.add(this.obj)

            this.light = new THREE.SpotLight("#ffffff",10000,10000,Math.PI/2*0.2, 1, 1)
            this.light.position.set(0,0,0)
            let targ = new THREE.Object3D()
            targ.position.set(0,0,-10)
            this.obj.add(targ)
            this.light.target = targ
            this.obj.add(this.light)


            let objectMat = new THREE.MeshStandardMaterial({ color: "#ff00ff", emissive: 0xaa00ff });
            let wingMat = new THREE.MeshStandardMaterial({ color: "#ff88ff", emissive: 0xffaaff });

            objectMat.emmissive = new THREE.Color().setRGB(0x8800ff)
            wingMat.emmissive = new THREE.Color().setRGB(0x8800ff)
            wingMat.emmissiveIntensity = 1


            this.body = new THREE.Mesh(new THREE.BoxGeometry(15,15,35), objectMat);
            this.body.position.set(0,0,0);
            this.obj.add(this.body );

            let wingSize = 1.5

            this.wingRight = new THREE.Mesh(new THREE.BoxGeometry(30*wingSize,5*wingSize,15*wingSize), wingMat);
            this.wingRight.position.set(18*wingSize,0,0);
            this.wingRight.rotateY(-0.2)
            this.obj.add(this.wingRight);

            this.wingLeft = new THREE.Mesh(new THREE.BoxGeometry(30*wingSize,5*wingSize,15*wingSize), wingMat);
            this.wingLeft.position.set(-18*wingSize,0,0);
            this.wingLeft.rotateY(0.2)
            this.obj.add(this.wingLeft);

            this.wingTail = new THREE.Mesh(new THREE.BoxGeometry(2.5*wingSize,15,10*wingSize), wingMat);
            this.wingTail.position.set(0,2,-5);
            this.wingTail.rotateX(-0.2)
            this.obj.add(this.wingTail);




            return(this)
        }

        fire(){
          let wep = weapons[this.weapon]

          if(frameTime-this.reload<wep.reload){
            return
          }
          this.reload = frameTime

          let rand = new THREE.Vector3().randomDirection().multiplyScalar(wep.scatter)

          let vec3 = wep.direction(this)

          let dir = vec3.clone().add(rand).normalize()

          this.fireVec(dir)
        }

        fireVec(dir){
            if(this.hunting){
            this.raycaster.set(this.obj.position,dir)
            const intersects = this.raycaster.intersectObjects([this.hunting.obj] )

            if(intersects.length>0){
              // intersects[0].object.setColorAt(intersects[0].instanceId,new THREE.Color( 0xffff00 ))
              console.log("hit")
              this.hunting.forces.roll += Math.random()*2-1
              this.hunting.forces.pitch += Math.random()*2-1
              this.hunting.forces.yaw += Math.random()*2-1
            }
          }
          

          new liney([...this.obj.position.toArray(),...this.obj.position.clone().add(dir.multiplyScalar(5000)).toArray()],this.shotColor)
        }


        delete(){
          this.obj.clear()
          this.tail.removeFromParent()
        }


        initAI(type="v1",aipidSettings=[72.5,-20]){
          this.AI = true
          this.AIdowns = {}
          this.memory = [];
          this.target = new THREE.Vector3(0,0,0)
          this.projPoint = new THREE.Vector3(0,0,0)
          this.castFrequency = 20;
          this.counter = 0;

          this.AIPID = new AIPID(this,...aipidSettings)
          // this.AIPID2 = new AIPID(this,0.1,0.03)

          this.turnDist = 2000
          this.AIupdate = AIs[type]

          this.targetBlock = outterObjectS(
            new THREE.BoxGeometry(10,10,10),
            "#ff00ff",
            this.target
          )
          this.up = (x=false)=>{
            this.AIdowns.w = x
            this.AIdowns.s = !x
          }
          this.right = (x=false)=>{
            this.AIdowns.d = x
            this.AIdowns.a = !x
          }

          this.pitchMulter = ()=>{return(Math.max(Math.min(this.vel/20,0.5),0.1))}
          this.rollMulter = ()=>{return(Math.max(Math.min(this.vel/10,2),0.3))}

          return(this)
        }

        cast(){
          let rand = new THREE.Vector3(
              Math.random() * 2 - 1,
              Math.random() * 2 - 1,
              Math.random() * 2 - 1
          ).multiplyScalar(0.1)

          this.raycaster.set(this.obj.position,this.dir.clone().add(rand).normalize())
          const intersects = this.raycaster.intersectObjects( world.collidables );

          if(intersects.length>0){
            if(intersects[0].instanceId!==undefined){
              intersects[0].object.setColorAt(intersects[0].instanceId,new THREE.Color( 0xffff00 ))
              // intersects[0].object.instanceColor.needsUpdate = true
            }
          }
        }

        updatePos(dt=1,debug=false){

          dt *= world.timeMult

          this.dir = this.obj.getWorldDirection(new THREE.Vector3()).negate()

          if(this.AI){
            this.counter += 1
            if(this.counter%this.castFrequency==0){
              this.cast()
            }
            this.AIupdate(this,dt)
          }

            this.tail.setMatrixAt(this.tailCounter%this.tailLength,this.obj.matrix)
            this.tailCounter += 1
          

          dt *= 0.04
          let adt = Math.abs(dt)

        
          let pitchMult = this.pitchMulter()
          let rollMult = this.rollMulter()

          if(this.downs.w){
            this.controls.pitch =  Math.min(1,this.controls.pitch+dt*this.controlSpeed*pitchMult)
          }  if(this.downs.s){
            this.controls.pitch = Math.max(-1,this.controls.pitch-dt*this.controlSpeed*pitchMult)
          }  

          if(this.downs.d){
            this.controls.roll = Math.max(-1,this.controls.roll-dt*this.controlSpeed*rollMult)
          }  if(this.downs.a){
            this.controls.roll =  Math.min(1,this.controls.roll+dt*this.controlSpeed*rollMult)
          } if(this.downs[" "] || this.downs["/"]){
            // this.vel += dt
            this.vel += dt
          } if(this.downs["q"]){
            this.vel *= 0.7 ** dt
            // this.vel *= 0.9 ** dt
          }



      this.controls.roll *= 0.9** adt
      this.controls.pitch *= 0.9** adt
    
      this.vel *= 0.97 ** dt
      this.vel *= (1-0.04*Math.abs(this.controls.pitch)) ** dt


      // Object.keys(this.controls).forEach((e)=>{
      //   if(e==="up"){this.forces[e] = this.controls[e];return}
      //   let mns = this.controls[e]-this.forces[e]
      //   this.forces[e] += Math.min(Math.abs(mns),Math.abs(mns/100)) * Math.sign(mns) * adt
      // })

      this.forces.roll *= 0.9** adt
      this.forces.pitch *= 0.9** adt
      this.forces.yaw *= 0.9** adt

    this.obj.rotateY( (this.controls.yaw+this.forces.yaw) * dt)
    this.obj.rotateZ( (this.controls.roll+this.forces.roll) * dt)
    this.obj.rotateX( (this.controls.pitch+this.forces.pitch) * dt)


    // this.upVector = new THREE.Vector3(0, 1, 0).applyQuaternion(this.obj.quaternion)
    // this.angleUp = this.upVector.angleTo(new THREE.Vector3(0,1,0))
    // this.vel.add(this.upVector.clone().multiplyScalar(this.forces.up*dt))




    this.dst = Infinity
 
    if(!this.locked){
      this.obj.translateZ(-this.vel*dt/0.04)
    }


  }
}

      class world{
        static timeMult = 1
        static cameraDrone = new fighter()
        static entities = [ 
          // new fighter().initAI(),
          this.cameraDrone, 
          // new fighter().initAI(),

        ]

        static cameraMount = new THREE.Object3D()
        static cameraRotX = 0 
        static cameraRotY = 0 

        static init(){
          this.cameraDrone.obj.add(this.cameraMount)
          this.cameraMount.rotation.order = "YXZ"
          this.cameraMount.add(camera)
          this.cameraDrone.downs = downs
        }
        static collidables = []
      }

      // function starcloud(){


      //   let count = Math.floor(21400)

      //   const vector = new THREE.Vector4();
      //   const positions = [];
      //   const offsets = [];
      //   const colors = [];
      //   const orientations = []; 
      //   const rotationDeltas = [];

      //   const v3 = new THREE.Vector3()

      //   let size = 225/100

      //   positions.push( 0, -size*2, 0 );
      //   positions.push( 0, size*2, 0 );
      //   positions.push( 0, size, size );



      //   for ( let i = 0; i < count; i ++ ) {

      //       // offsets
      //       let [x,y,z] = [Math.random()*galazyBoxSize, Math.random()*galazyBoxSize, Math.random()*galazyBoxSize];
      //       offsets.push(x,y,z);
      //       // colors
      //       colors.push( Math.random(), Math.random(), Math.random(),1);
      //       // orientation
      //       vector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );
      //       vector.normalize();
      //       orientations.push( vector.x, vector.y, vector.z, vector.w );

      //       let theta = Math.PI*2

      //       v3.randomDirection()
      //       vector.set(
      //         v3.x * Math.sin(theta/2),
      //         v3.y * Math.sin(theta/2),
      //         v3.z * Math.sin(theta/2),
      //         Math.cos(theta/2)
      //       )

      //       // vector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, 1 );
      //       vector.normalize();
      //       rotationDeltas.push( vector.x, vector.y, vector.z, vector.w );
      //   }

      //   // mesh.instanceMatrix.needsUpdate = true

      //   const geometry2 = new THREE.BufferGeometry();



      //   geometry2.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
      //   geometry2.setAttribute( 'offset', new THREE.InstancedBufferAttribute( new Float32Array( offsets ), 3 ) );
      //   geometry2.setAttribute( 'color', new THREE.InstancedBufferAttribute( new Float32Array( colors ), 4 ) );
      //   geometry2.setAttribute( 'orientationStart', new THREE.InstancedBufferAttribute( new Float32Array( orientations ), 4 ) );
      //   geometry2.setAttribute( 'rotationDelta', new THREE.InstancedBufferAttribute( new Float32Array( rotationDeltas ), 4 ) );
      //   let mesh2 = new InstancedMesh2(geometry2, new THREE.RawShaderMaterial( {
      //     uniforms: {
      //       'time': { value: 1.0 },
      //       'sineTime': { value: 1.0 },
      //       'cameraPos': { value: world.cameraDrone.obj.position },
      //     },
      //     vertexShader: document.getElementById( 'vertexShader2' ).textContent,
      //     fragmentShader: document.getElementById( 'fragmentShader2' ).textContent,
      //     side: THREE.DoubleSide,
      //     forceSinglePass: true,
      //     transparent: false

      //   }))
      //   geometry2.computeBoundingSphere()
      //   geometry2.boundingSphere.radius = Infinity
      //   window.gem = geometry2
      //   mesh2.name = "starcloud"
      //   scene.add( mesh2 );
      //   world.starcloud = mesh2
      // }


      function starcloud(count=5000,mov=()=>{},geometry = new THREE.BoxGeometry(1, 1, 1)){

          var materials = new THREE.MeshStandardMaterial({ color: "#FFFFFF",
            vertexShader: document.getElementById( 'vertexShader2' ).textContent,
            fragmentShader: document.getElementById( 'fragmentShader2' ).textContent
          })

          // geometry.computeVertexNormals() // delete if not found useful

          let mesh = new InstancedMesh2( geometry, materials, count );
          mesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // will be updated every frame
          scene.add(mesh);
          mesh.addInstances(count);
          mesh.initUniformsPerInstance({ fragment: { orientationStart: 'vec4', rotationDelta: 'vec4'} });

          let vector = new THREE.Vector4()
          let v3 = new THREE.Vector3()

          let dummy = new THREE.Object3D()
          let theta = Math.PI/2
          for ( let i = 0; i < count; i ++) {
              mov(dummy,i)
              dummy.updateMatrix();


              vector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );
              vector.normalize();

              mesh.setUniformAt(i, 'orientationStart', vector);
              v3.randomDirection()
              vector.set(
                v3.x * Math.sin(theta/2),
                v3.y * Math.sin(theta/2),
                v3.z * Math.sin(theta/2),
                Math.cos(theta/2)
              )

            // vector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, 1 );
            vector.normalize();


              mesh.setUniformAt(i, 'rotationDelta', vector);
              mesh.setMatrixAt( i, dummy.matrix );
          }
          return(mesh)
      }
      
      function starcloud2(){


        let count = Math.floor(21400)

        const vector = new THREE.Vector4();
        const positions = [];
        const offsets = [];
        const colors = [];
        const orientations = []; // wow! optimizable, later you can just rotate the positions at the start. right now the positions array is useless

        let size = 225/100

        positions.push( 0, -size*2, 0 );
        positions.push( 0, size*2, 0 );
        positions.push( 0, size, size );


        let galazyBoxSize = 5000

        for ( let i = 0; i < count; i ++ ) {

            // offsets
            let [x,y,z] = [Math.random()*galazyBoxSize, Math.random()*galazyBoxSize, Math.random()*galazyBoxSize];
            offsets.push(x,y,z);
            // colors
            colors.push( Math.random(), Math.random(), Math.random(),1);
            // orientation
            vector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );
            vector.normalize();
            orientations.push( vector.x, vector.y, vector.z, vector.w );
        }

        // mesh.instanceMatrix.needsUpdate = true

        const geometry2 = new THREE.InstancedBufferGeometry();

        geometry2.instanceCount = count; // set so its initialized for dat.GUI, will be set in first draw otherwise
        geometry2.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
        geometry2.setAttribute( 'offset', new THREE.InstancedBufferAttribute( new Float32Array( offsets ), 3 ) );
        geometry2.setAttribute( 'color', new THREE.InstancedBufferAttribute( new Float32Array( colors ), 4 ) );
        geometry2.setAttribute( 'orientation', new THREE.InstancedBufferAttribute( new Float32Array( orientations ), 4 ) );
        let mesh2 = new THREE.Mesh(geometry2, new THREE.RawShaderMaterial( {

        uniforms: {
          'time': { value: 1.0 },
          'sineTime': { value: 1.0 },
          'cameraPos': { value: world.cameraDrone.obj.position },
        },
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
        side: THREE.DoubleSide,
        forceSinglePass: true,
        transparent: false

        } ))
        geometry2.computeBoundingSphere()
        geometry2.boundingSphere.radius = Infinity
        window.gem = geometry2
        mesh2.name = "starcloud"
        scene.add( mesh2 );
        world.starcloud = mesh2
      }
      


      var rand = (x)=>{
        if(x == undefined){return(Math.random())}
        if(x < 1){return(Math.random()<x)}
        return(Math.random()*x)
      }



      //iin
      function init() {
        scene.add(new THREE.AmbientLight(0x888888, 1));

        for(let i = 0; i< 100; i++){
          // outterObjectS(
          //   new THREE.BoxGeometry(5,5,5),
          //   "#ff00ff",
          //   new THREE.Vector3(Math.random()*200-100,Math.random()*200-100,Math.random()*200-100)
          // )
          new liney([rand(500),rand(500),rand(500),rand(500),rand(500),rand(500)])
        }


        let s = instance(5,(x)=>{
          x.position.set(rand(10000)-5000,rand(10000)-5000,rand(10000)-5000)
          x.scale.set(rand(100),rand(100),rand(100))
        })
        for(let i = 0; i < 5000; i++){
          let color = new THREE.Color()
          color.setHex(Math.floor(0xffffff*Math.random()))
          s.setColorAt(i, color);
        }
        world.collidables.push(s)

        world.init()
        starcloud()


        world.cameraDrone.initAI()
        world.cameraDrone.AIpassive = true




        window.THREE = THREE;
        window.fighter = fighter;
        window.world = world;
        window.camera = camera;
        window.scene = scene

        window.summonDrone = ()=>{world.entities.push(new fighter().initAI())}
        window.target = (x)=>{world.cameraDrone.hunting = world.entities[x]}
      }


      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        canvas.fitScreenSize()

        renderer.setSize(window.innerWidth, window.innerHeight);
      }


      function box(x,y,d,col,i=1,z=1){
        d/=2
        ctx.fillStyle = col
        ctx.fillRect(x-d*i+Width/2,y-d*z+Height/2,d*2*i,d*2*z)
      }


      var startDate = Date.now()
      var frameTime = Date.now()


      var fpsLimiter = Date.now()

      function animate() {

        frameTime = Date.now()
        requestAnimationFrame(animate);
        if(frameTime-fpsLimiter < 16){
          return;
        }
        fpsLimiter = frameTime;

        const delta = clock.getDelta();



        world.entities.forEach((e)=>{
          e.updatePos(1)
          // e.updatePos(delta*100)
        })

        // world.starcloud.material.uniforms['sineTime'].value = Math.sin((Date.now()-startDate) * 0.0005);
        // world.starcloud.material.uniforms['time'].value = (Date.now()-startDate)*0.005


        if(downs.j){
          camera.rotateY(0.02)
        }
        if(downs.l){
          camera.rotateY(-0.02)
        }
        if(downs.i){
          camera.rotateX(0.02)
        }
        if(downs.k){
          camera.rotateX(-0.02)
        }

        if(downs["."]){
          world.cameraDrone.controls.roll = world.cameraDrone.controls.pitch = world.cameraDrone.vel = 0
        }
        if(downs[","]){
          if(world.timeMult == 0){world.timeMult = 1} else {
            world.timeMult = 0
          }
        }



        ctx.clearRect(0,0,Width,Height)

        cameraGUI(delta)

        if(world.cameraLocked){

          // world.cameraMount.lookAt(world.cameraDrone.targetDir.clone().negate())
          world.cameraMount.lookAt(world.cameraDrone.targetVect.clone().add(world.cameraDrone.obj.position))
          dbg("targetDir: ",JSON.stringify(world.cameraDrone.targetDir.clone().toArray()))
          dbg("mountDir: ",JSON.stringify(world.cameraDrone.targetDir.clone().toArray()))
          
          // camera.lookAt(world.cameraDrone.obj.position)

          world.cameraMount.rotateX(world.cameraRotX)
          world.cameraMount.rotateY(world.cameraRotY)


          // camera.position.set(...world.cameraDrone.targetDir.clone().multiplyScalar(600).toArray())
          // camera.rotation.z = 0
          // let upVec = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion)
          // camera.position.add(upVec.multiplyScalar(100))

        }



        let dbgstr = ""
        let dbgdiv = document.getElementById("debug")
        Object.keys(debugData).forEach((e)=>{
          dbgstr += e + ": "+debugData[e] + "\n"
          debugData[e] = "not updated"
        })
        dbgdiv.innerText = dbgstr

        debug();

        renderer.render(scene, camera);

      }

      window.debug = ()=>{}


      window.scenario = (x)=>{
        summonDrone(); target(1); world.cameraDrone.AIpassive = x; world.entities[1].controls.roll = 1;world.cameraDrone.weapon = "railgun";
world.cameraLocked = world.entities[1]
      }

      window.lockCamera = ()=>{
        world.cameraLocked = true;
        // camera.position.set(0,0,200)
        // camera.lookAt(0,0,0)
      }


      function cameraGUI(dt){
        box(0,0,10,"red")
        let dr = world.cameraDrone

        if(dr.AIdowns.w){
          box(0,-20,10,"green")
        }
        if(dr.AIdowns.s){
          box(0,20,10,"green")
        }
        if(dr.AIdowns.a){
          box(-20,0,10,"green")
        }
        if(dr.AIdowns.d){
          box(20,0,10,"green")
        }

        if(dr.controls.pitch > 0){
          box(0,-30,10,"pink")
        } else if(dr.controls.pitch < 0){
          box(0,30,10,"pink")
        }

        box(0,40,10,dr.AIPID.dPitch>0?"yellow":"red",dr.AIPID.dPitch*1000)
        box(0,60,10,"orange",dr.projPitchAng*10)
        box(0,70,10,"#FFFFAA",dr.projPitchAng2*10)
        box(0,90,5,"#00FFFF",dt*1000)


      }






      document.addEventListener("wheel",(e)=>{
          camera.translateZ(e.deltaY)
      })




       document.addEventListener("keydown",(e)=>{
          if(e.repeat){return}

            if(e.key=="r"){
            } if(e.key == "R"){
              window.location.reload()
            } if(e.key == "1"){
            } if(e.key == "2"){
            } 
            if(e.key == "i"){
            }


            if(e.key == "Enter"){
            }

            if(e.key == "j"){
            }


            if(e.key == "Tab"){
              e.preventDefault()
            }
          downs[e.key] = true
        })

        document.addEventListener("mousedown",(e)=>{
          downs["M"+e.button] = true
        })
        document.addEventListener("mouseup",(e)=>{
          downs["M"+e.button] = false
        })
        document.addEventListener("keyup",(e)=>{
          if(e.repeat){return}

          downs[e.key] = false
        })

        document.addEventListener("contextmenu",(e)=>{
          e.preventDefault()
        })

        document.addEventListener("mousemove",(e)=>{

            mouseX = e.clientX
            mouseY = e.clientY

            if(downs["M2"]){

              world.cameraRotY -= e.movementX/300
              world.cameraRotX -= e.movementY/300

              world.cameraMount.rotation.set(world.cameraRotX,world.cameraRotY,0)
              // world.cameraMount.rotateOnAxis(new THREE.Vector3(1,0,0),e.movementY/100)
              // world.cameraMount.rotateOnAxis(new THREE.Vector3(0,1,0),e.movementX/100)

            }

        })



      document.addEventListener("mousedown",(e)=>{
        if(e.button==2){return}
          mouseX = event.clientX / window.innerWidth * 2 - 1;
          mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

          world.cameraDrone.raycaster.setFromCamera({x:mouseX,y:mouseY},camera)
          // let dir = world.cameraDrone.obj.position.clone().add(world.cameraDrone.raycaster.ray.direction.clone())
            // let ar = [...world.cameraDrone.obj.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(400)).toArray(),...dir]
          // new liney(ar)
          world.cameraDrone.fireVec(world.cameraDrone.raycaster.ray.direction.clone())
      })




















      window.test = {
        "1":(t=1,x=1000)=>{
                let f1 = new fighter()
                f1.downs.w = true
                f1.downs.d = true
                f1.downs[" "] = true
                for(let i = 0; i < x; i++){
                  f1.updatePos(t)
                }
                return(f1)
            },
        "2":()=>{
                let f1 = new fighter()
                f1.downs.w = true
                  f1.updatePos(1,true)
                return(f1)
            },
        "3":(t=1,x=1000,aip)=>{
          if(window.deb3arr === undefined){window.deb3arr = []}
                let f1 = new fighter()
                f1.initAI("v1",aip)
                f1.downs.w = true
                f1.downs.d = true
                f1.downs[" "] = true
                for(let i = 0; i < x; i++){
                  f1.updatePos(t)
                }
                window.deb3arr.push(f1)
                return(f1)
            },
        "4":(d,v)=>{


          world.cameraDrone.obj.quaternion.identity()
          world.cameraDrone.AIpassive = false
          world.cameraDrone.target.set(0,-2000,2000)
          world.cameraDrone.AIPID.dFactor = d
          world.cameraDrone.AIPID.velFactor = v
          camera.position.set(0,0,0)
          camera.lookAt(0,0,-1)
          world.cameraDrone.locked= true

        }
      }
























      init();
      animate();
    </script>
  </body>
</html>











