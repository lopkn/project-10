<!DOCTYPE html>
<html>
  <meta charset="UTF-8" />
  <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />

  <style>
    html,
      body {
        margin: 0;
        padding: 0;
      }

    #debug {
      position: absolute;
      top:0;
      left:0;
      color: #ff9999;
    }

  </style>
  <body>

    <div id="debug"></div>




     <script id="vertexShader" type="x-shader/x-vertex">
    precision highp float;

    uniform float sineTime;
    uniform float time;

    uniform vec3 cameraPos;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    attribute vec3 position;
    attribute vec3 offset;
    attribute vec4 color;
    attribute vec4 orientationStart;
    attribute vec4 orientationEnd;

    varying vec3 vPosition;
    varying vec4 vColor;

    vec3 quat_transform(vec4 q, vec3 v) {
      return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
    }

    void main(){

      float size = 5000.0;
      vPosition = offset;
      vPosition.x += floor((cameraPos.x-vPosition.x)/size + 0.5)*size;
      vPosition.y += floor((cameraPos.y-vPosition.y)/size + 0.5)*size;
      vPosition.z += floor((cameraPos.z-vPosition.z)/size + 0.5)*size;

      //vec4 orientation = normalize( mix( orientationStart, orientationEnd, abs(0.5+(time*0.5)) ) );
      vec4 orientation = orientationStart;
      vPosition = vPosition + quat_transform(orientation,position);
      //cool Effect vPosition = offset + quat_transform(orientationStart,position);
      // cool effect vPosition.x += vPosition.x-cameraPos.x;




      vec3 vcV = cross( orientation.xyz, vPosition );


      vColor = color;

      gl_Position = projectionMatrix * modelViewMatrix * vec4( vPosition, 1.0 );

    }

  </script>

  <script id="fragmentShader" type="x-shader/x-fragment">

    precision highp float;

    uniform float time;

    varying vec3 vPosition;
    varying vec4 vColor;

    void main() {

      vec4 color = vec4( vColor );
      //color.r += sin( 1.0 * time  + 3.14) * 1200.5;
      color.r = time;

      gl_FragColor = color;

    }

  </script>



    <script type="importmap">
        {
        "imports": {
            "three": "../../../node_modules/three/build/three.module.js",
            "three/examples/jsm/shaders/CopyShader.js": "https://unpkg.com/three@0.178.0/examples/jsm/shaders/CopyShader.js",
            "three/examples/jsm/postprocessing/EffectComposer.js": "https://unpkg.com/three@0.178.0/examples/jsm/postprocessing/EffectComposer.js",
            "three/examples/jsm/postprocessing/RenderPass.js": "https://unpkg.com/three@0.178.0/examples/jsm/postprocessing/RenderPass.js",
            "three/examples/jsm/postprocessing/ShaderPass.js": "https://unpkg.com/three@0.178.0/examples/jsm/postprocessing/ShaderPass.js",
            "three/examples/jsm/postprocessing/OutlinePass.js": "https://unpkg.com/three@0.178.0/examples/jsm/postprocessing/OutlinePass.js",
            "three/examples/jsm/postprocessing/OutputPass.js": "https://unpkg.com/three@0.178.0/examples/jsm/postprocessing/OutputPass.js",
            "three/examples/jsm/shaders/FXAAShader.js":"https://unpkg.com/three@0.178.0/examples/jsm/shaders/FXAAShader.js",
            "three/examples/jsm/loaders/GLTFLoader.js":"https://unpkg.com/three@0.178.0/examples/jsm/loaders/GLTFLoader.js",


            "three/addons/": "https://unpkg.com/three@0.178.0/examples/jsm/",

            "three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.9.0/build/index.module.js",

            "@three.ez/instanced-mesh": "https://cdn.jsdelivr.net/npm/@three.ez/instanced-mesh/build/index.js",
            "bvh.js": "https://cdn.jsdelivr.net/npm/bvh.js/build/index.js",

            "@three.ez/simplify-geometry": "https://cdn.jsdelivr.net/npm/@three.ez/simplify-geometry@0.0.1/build/index.js",
            "meshoptimizer": "https://cdn.jsdelivr.net/npm/meshoptimizer@0.23.0/+esm"
        }
    }
    </script>


    <script type="module">

        import * as THREE from 'three';
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
        import { OutlinePass } from 'three/examples/jsm/postprocessing/OutlinePass.js';
        import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';
        import { FXAAShader } from 'three/examples/jsm/shaders/FXAAShader.js';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { Line2 } from 'https://unpkg.com/three@0.178.0/examples/jsm/lines/Line2.js';
        import { LineGeometry } from 'https://unpkg.com/three@0.178.0/examples/jsm/lines/LineGeometry.js';
        // import { GeometryUtils } from 'https://unpkg.com/three@0.178.0/examples/jsm/utils/GeometryUtils.js';
        import { LineMaterial } from 'https://unpkg.com/three@0.178.0/examples/jsm/lines/LineMaterial.js';
        import { LineSegments2 } from 'https://unpkg.com/three@0.178.0/examples/jsm/lines/LineSegments2.js';
        import { LineSegmentsGeometry } from 'https://unpkg.com/three@0.178.0/examples/jsm/lines/LineSegmentsGeometry.js';
        import { acceleratedRaycast, computeBatchedBoundsTree } from 'three-mesh-bvh';

        import { InstancedMesh2 } from '@three.ez/instanced-mesh';
        import { createRadixSort} from '@three.ez/instanced-mesh';

      const clock = new THREE.Clock();
      const scene = new THREE.Scene();

      var foggy = 0
      var downs = {}

      const camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.01,
        999999
      );
      camera.position.set(0, 0, 0);

    
      function instance(count,mov=()=>{},geometry = new THREE.BoxGeometry(1, 1, 1)){

          var materials = new THREE.MeshStandardMaterial({ color: "#FFFFFF"/*, roughness:0, metalness: 0.8*/})

          // geometry.computeVertexNormals() // delete if not found useful

          let mesh = new InstancedMesh2( geometry, materials, count );
          mesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // will be updated every frame
          scene.add(mesh);
          mesh.addInstances(count);

          let dummy = new THREE.Object3D()
          for ( let i = 0; i < count; i ++) {
              mov(dummy,i)
              dummy.updateMatrix();
              mesh.setMatrixAt( i, dummy.matrix );
          }
          return(mesh)
      }

      function addLight(x,objectPos){
        let l = new THREE.PointLight(0xffee50,2*(Math.random()*0.4+0.4)*x/50,8)
        l.position.copy(objectPos);
        scene.add(l)
      }



      // RENDERER
      const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
      renderer.shadowMap.enabled = true;
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(foggy);
      window.addEventListener("resize", onWindowResize);
      document.body.appendChild(renderer.domElement);

      // CONTROLS
      // const controls = new THREE.OrbitControls(camera, renderer.domElement);
      // controls.minDistance = 2;
      // controls.maxDistance = 20;
      // controls.update();



      var debugData = {}

      function dbg(val,str){
        debugData[val] = str
        return(str)
      }





      var AIs = { // target
        "v1":(x)=>{


          x.downs[" "]=true

          if(x.hunting){
            x.target = x.hunting.obj.position.clone()
          }

          x.targetVect = x.obj.position.clone().sub(x.target)
          // x.targRollAng = x.up.clone().dot(x.targetDir)
          x.targetDir = x.targetVect.clone().normalize()
          x.targDist = x.targetVect.length()
          x.targAng = x.dir.clone().dot(x.targetDir) // -1 means perfectly pointed towards target

          x.rightVec = new THREE.Vector3(1, 0, 0).applyQuaternion(x.obj.quaternion)
          x.upVec = new THREE.Vector3(0, 1, 0).applyQuaternion(x.obj.quaternion)
          x.targRollAng = x.rightVec.clone().dot(x.targetDir)
          x.targPitchAng = x.upVec.clone().dot(x.targetDir) // 0 means perpendicular, -1 means head pointed toward target
          x.pitchDir = !(x.targPitchAng>0)

          x.targetBlock.position.copy(x.target)

          // PITCH logic (on same plane)

          // if(x.targDist > 2000 && x.targAng > -0.6){
          //   x.downs.w = true
          // } else {
          //   x.downs.w = false

          //   if(x.controls.pitch>0.1){
          //     x.downs.s = true
          //   } else {
          //     x.downs.s = false
          //   }
          // }
            // console.log(x.targPitchAng)

            dbg("pitch ang",x.targPitchAng)
            dbg("target ang",x.targAng)

          if(dbg("far",x.targDist > 2000)){

            if(x.targAng > -0.6){ // if not pointed near target
              x.up(x.pitchDir)
              

            } else {
              x.downs.w = x.downs.s = false
            }


          } 
           if(dbg("precise",x.targAng < -0.6)){ // pointed near target, precise manuvers needed
              x.downs.w = x.downs.s = false
              if(x.controls.pitch>0.1 && x.pitchDir){
                x.up(!x.pitchDir)
              } else if(x.controls.pitch<-0.1 && !x.pitchDir){
                x.up(!x.pitchDir)
              }
            }

          // ROLL logic

          if(Math.abs(x.targRollAng)<0.3){

            if(x.targRollAng > 0){
              x.right(!x.pitchDir)
            } else {
              x.right(x.pitchDir)
            }

          }


          //panic
          if(x.targDist > 6000 || x.paniced){
              x.downs[" "] = false
            }

          dbg("PITCH UP",x.downs.w)
          dbg("PITCH DOWN",x.downs.s)
          dbg("ACCELERATE",x.downs[" "])

        }
      }








      function outterObjectS(objectGeom, objectColor, objectPos) {
        const objectMat = new THREE.MeshStandardMaterial({ color: objectColor });
        const object = new THREE.Mesh(objectGeom, objectMat);
        object.position.copy(objectPos);
        scene.add(object);
        return(object)
      }

      class liney{
        constructor(arr){
          this.pos = arr
          let geometry = new LineGeometry();
          geometry.setPositions( this.pos );
          geometry.setColors([1,1,1,0,1,1]);
          geometry.computeBoundingSphere()
          geometry.boundingSphere.radius = Infinity


          let matLine = new LineMaterial( {

            color: 0xffffff,
            linewidth: 5, // in world units with size attenuation, pixels otherwise
            vertexColors: true,

            dashed: false,
            alphaToCoverage: false,
            worldUnits: true

          } );
          
          let line = new Line2( geometry, matLine );
          line.scale.set( 1, 1, 1 );
          line.frustumCulled = false
          line.computeLineDistances()
          scene.add( line );
        }

        update(dt){
          
        }
      }


      class fighter{
        constructor(){
          this.obj = new THREE.Object3D()
          this.vel = 0
          this.obj.position.set(0,0,0);
          this.dir = new THREE.Vector3(0,0,1)

          this.tailLength = 500
          this.tailCounter = 0;
          this.tail = instance(this.tailLength,undefined,new THREE.BoxGeometry(10, 0.1, 10))
          this.tail.frustumCulled = false
          this.raycaster = new THREE.Raycaster()
          this.downs = {}


            this.controls = {
              "up":0,
              "pitch":0,
              "roll":0,
              "yaw":0
            }

            this.forces = {
              "up":0,
              "pitch":0,
              "roll":0,
              "yaw":0
            }
            scene.add(this.obj)

            this.light = new THREE.SpotLight("#ffffff",10000,10000,Math.PI/2*0.2, 1, 1)
            this.light.position.set(0,0,0)
            let targ = new THREE.Object3D()
            targ.position.set(0,0,-10)
            this.obj.add(targ)
            this.light.target = targ
            this.obj.add(this.light)

            return(this)
        }

        initAI(type="v1"){
          this.AI = true
          this.memory = [];
          this.target = new THREE.Vector3(0,0,0)
          this.castFrequency = 1;
          this.counter = 0;

          this.AIupdate = AIs[type]

          this.targetBlock = outterObjectS(
            new THREE.BoxGeometry(15,15,15),
            "#ff00ff",
            this.target
          )
          this.up = (x=false)=>{
            this.downs.w = x
            this.downs.s = !x
          }
          this.right = (x=false)=>{
            this.downs.d = x
            this.downs.a = !x
          }
          return(this)
        }

        cast(){
          let rand = new THREE.Vector3(
              Math.random() * 2 - 1,
              Math.random() * 2 - 1,
              Math.random() * 2 - 1
          ).multiplyScalar(0.1)

          this.raycaster.set(this.obj.position,this.dir.add(rand).normalize().negate())
          const intersects = this.raycaster.intersectObjects( world.collidables );

          if(intersects.length>0){
            if(intersects[0].instanceId!==undefined){
              intersects[0].object.setColorAt(intersects[0].instanceId,new THREE.Color( 0xffff00 ))
              // intersects[0].object.instanceColor.needsUpdate = true
            }
          }
        }

        updatePos(dt=1){

          this.dir = this.obj.getWorldDirection(new THREE.Vector3())

          if(this.AI){
            this.counter += 1
            if(this.counter%this.castFrequency==0){
              this.cast()
            }
            this.AIupdate(this)
          }

            this.tail.setMatrixAt(this.tailCounter%this.tailLength,this.obj.matrix)
            this.tailCounter += 1
          

          dt *= 0.04
          let adt = Math.abs(dt)



        let controlSpeed = 0.1
        let pitchMult = Math.max(Math.min(this.vel/20,0.5),0.1)
        let rollMult = Math.max(Math.min(this.vel/10,2),0.3)

        if(this.downs.w){
          this.controls.pitch =  Math.min(1,this.controls.pitch+dt*controlSpeed*pitchMult)
        }  if(this.downs.s){
          this.controls.pitch = Math.max(-1,this.controls.pitch-dt*controlSpeed*pitchMult)
        }  

        if(this.downs.d){
          this.controls.roll = Math.max(-1,this.controls.roll-dt*controlSpeed*rollMult)
        }  if(this.downs.a){
          this.controls.roll =  Math.min(1,this.controls.roll+dt*controlSpeed*rollMult)
        } if(this.downs[" "] || this.downs["/"]){
          this.vel += dt
        } if(this.downs["q"]){
          this.vel *= 0.9 ** dt
        }



      this.controls.roll *= 0.9** adt
      this.controls.pitch *= 0.9** adt
    
      this.vel *= 0.97 ** dt
      this.vel *= (1-0.04*Math.abs(this.controls.pitch)) ** dt


      // Object.keys(this.controls).forEach((e)=>{
      //   if(e==="up"){this.forces[e] = this.controls[e];return}
      //   let mns = this.controls[e]-this.forces[e]
      //   this.forces[e] += Math.min(Math.abs(mns),Math.abs(mns/100)) * Math.sign(mns) * adt
      // })

    this.obj.rotateY(this.controls.yaw* dt)
    this.obj.rotateZ(this.controls.roll* dt)
    this.obj.rotateX(this.controls.pitch* dt)


    // this.upVector = new THREE.Vector3(0, 1, 0).applyQuaternion(this.obj.quaternion)
    // this.angleUp = this.upVector.angleTo(new THREE.Vector3(0,1,0))
    // this.vel.add(this.upVector.clone().multiplyScalar(this.forces.up*dt))




    this.dst = Infinity
 
    this.obj.translateZ(-this.vel)


  }
}

      class world{
        static cameraDrone = new fighter()
        static entities = [ this.cameraDrone, new fighter().initAI(),

        ]
        static init(){
          this.cameraDrone.obj.add(camera)
          this.cameraDrone.downs = downs
        }
        static collidables = []
      }


      function starcloud(){


        let count = Math.floor(21400)

        const vector = new THREE.Vector4();
        const positions = [];
        const offsets = [];
        const colors = [];
        const orientationsStart = [];
        const orientationsEnd = [];

        let size = 225/100

        positions.push( 0, -size*2, 0 );
        positions.push( 0, size*2, 0 );
        positions.push( 0, size, size );




        let galazyBoxSize = 5000

        for ( let i = 0; i < count; i ++ ) {

            // offsets
            let [x,y,z] = [Math.random()*galazyBoxSize, Math.random()*galazyBoxSize, Math.random()*galazyBoxSize];
            offsets.push(x,y,z);
            // colors
            colors.push( Math.random(), Math.random(), Math.random(),1);
            // orientation start
            vector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );
            vector.normalize();
            orientationsStart.push( vector.x, vector.y, vector.z, vector.w );
            // orientation end
            vector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );
            vector.normalize();
            orientationsEnd.push( vector.x, vector.y, vector.z, vector.w );
        }

        // mesh.instanceMatrix.needsUpdate = true

        const geometry2 = new THREE.InstancedBufferGeometry();

        geometry2.instanceCount = count; // set so its initialized for dat.GUI, will be set in first draw otherwise
        geometry2.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
        geometry2.setAttribute( 'offset', new THREE.InstancedBufferAttribute( new Float32Array( offsets ), 3 ) );
        geometry2.setAttribute( 'color', new THREE.InstancedBufferAttribute( new Float32Array( colors ), 4 ) );
        geometry2.setAttribute( 'orientationStart', new THREE.InstancedBufferAttribute( new Float32Array( orientationsStart ), 4 ) );
        geometry2.setAttribute( 'orientationEnd', new THREE.InstancedBufferAttribute( new Float32Array( orientationsEnd ), 4 ) );
        let mesh2 = new THREE.Mesh(geometry2, new THREE.RawShaderMaterial( {

        uniforms: {
          'time': { value: 1.0 },
          'sineTime': { value: 1.0 },
          'cameraPos': { value: world.cameraDrone.obj.position },
        },
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
        side: THREE.DoubleSide,
        forceSinglePass: true,
        transparent: false

        } ))
        geometry2.computeBoundingSphere()
        geometry2.boundingSphere.radius = Infinity
        window.gem = geometry2
        mesh2.name = "starcloud"
        scene.add( mesh2 );
        world.starcloud = mesh2
      }
      


      var rand = (x)=>{
        if(x == undefined){return(Math.random())}
        if(x < 1){return(Math.random()<x)}
        return(Math.random()*x)
      }



      //iin
      function init() {
        scene.add(new THREE.AmbientLight(0x888888, 1));

        for(let i = 0; i< 100; i++){
          // outterObjectS(
          //   new THREE.BoxGeometry(5,5,5),
          //   "#ff00ff",
          //   new THREE.Vector3(Math.random()*200-100,Math.random()*200-100,Math.random()*200-100)
          // )
          new liney([rand(500),rand(500),rand(500),rand(500),rand(500),rand(500)])
        }


        let s = instance(5000,(x)=>{
          x.position.set(rand(10000)-5000,rand(10000)-5000,rand(10000)-5000)
          x.scale.set(rand(100),rand(100),rand(100))
        })
        for(let i = 0; i < 5000; i++){
          let color = new THREE.Color()
          color.setHex(Math.floor(0xffffff*Math.random()))
          s.setColorAt(i, color);
        }
        world.collidables.push(s)

        world.init()
        starcloud()


        world.cameraDrone.initAI()


        window.THREE = THREE;
        window.fighter = fighter;
        window.world = world;
        window.camera = camera;
        window.scene = scene
      }


      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }


      var startDate = Date.now()
      function animate() {
        const delta = clock.getDelta();



        requestAnimationFrame(animate);
        renderer.render(scene, camera);

        world.entities.forEach((e)=>{
          e.updatePos(delta*100)
        })
        world.starcloud.material.uniforms['time'].value = Math.sin((Date.now()-startDate) * 0.0005);


        if(downs.j){
          camera.rotateY(0.02)
        }
        if(downs.l){
          camera.rotateY(-0.02)
        }
        if(downs.i){
          camera.rotateX(0.02)
        }
        if(downs.k){
          camera.rotateX(-0.02)
        }






        let dbgstr = ""
        let dbgdiv = document.getElementById("debug")
        Object.keys(debugData).forEach((e)=>{
          dbgstr += e + ": "+debugData[e] + "\n"
          debugData[e] = "not updated"
        })
        dbgdiv.innerText = dbgstr



      }


       document.addEventListener("keydown",(e)=>{
          if(e.repeat){return}

            if(e.key=="r"){
            } if(e.key == "R"){
              window.location.reload()
            } if(e.key == "1"){
            } if(e.key == "2"){
            } 
            if(e.key == "i"){
            }


            if(e.key == "Enter"){
            }

            if(e.key == "j"){
            }


            if(e.key == "Tab"){
              e.preventDefault()
            }
          downs[e.key] = true
        })

        document.addEventListener("mousedown",(e)=>{
          downs["M"+e.button] = true
        })
        document.addEventListener("mouseup",(e)=>{
          downs["M"+e.button] = false
        })
        document.addEventListener("keyup",(e)=>{
          if(e.repeat){return}

          downs[e.key] = false
        })

      init();
      animate();
    </script>
  </body>
</html>











