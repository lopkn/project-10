<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - geometry - cube</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <!-- <script src="https://threejs.org/build/three.min.js"></script> -->
    <!-- <script src="https://cdn.skypack.dev/three@0.129.0/build/three.module.js"></script> -->

    <!-- <script src="https://unpkg.com/three@0.178.0/build/three.cjs"></script> -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" integrity="sha512-n8IpKWzDnBOcBhRlHirMZOUvEq2bLRMuJGjuVqbzUJwtTsgwOgK5aS0c1JA647XWYfqvXve8k3PtZdzpipFjgg==" crossorigin="anonymous"></script> -->
<!--     <script src="/socket.io/socket.io.js"></script>
 <script src="https://cdn.socket.io/3.1.3/socket.io.min.js" integrity="sha384-cPwlPLvBTa3sKAgddT6krw0cJat7egBga3DJepJyrLl4Q9/5WLra3rrnMcyTyOnh" crossorigin="anonymous"></script> -->

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>

  <body>




    <!-- <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script> -->

    <!-- <script> -->
<script src="//cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>

          <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.178.0/build/three.module.js",
            "three/examples/jsm/shaders/CopyShader.js": "https://unpkg.com/three@0.178.0/examples/jsm/shaders/CopyShader.js",
            "three/examples/jsm/postprocessing/EffectComposer.js": "https://unpkg.com/three@0.178.0/examples/jsm/postprocessing/EffectComposer.js",
            "three/examples/jsm/postprocessing/RenderPass.js": "https://unpkg.com/three@0.178.0/examples/jsm/postprocessing/RenderPass.js",
            "three/examples/jsm/postprocessing/ShaderPass.js": "https://unpkg.com/three@0.178.0/examples/jsm/postprocessing/ShaderPass.js",
            "three/examples/jsm/postprocessing/OutlinePass.js": "https://unpkg.com/three@0.178.0/examples/jsm/postprocessing/OutlinePass.js",
            "three/examples/jsm/postprocessing/OutputPass.js": "https://unpkg.com/three@0.178.0/examples/jsm/postprocessing/OutputPass.js",
            "three/examples/jsm/shaders/FXAAShader.js":"https://unpkg.com/three@0.178.0/examples/jsm/shaders/FXAAShader.js",
            "three/examples/jsm/loaders/GLTFLoader.js":"https://unpkg.com/three@0.178.0/examples/jsm/loaders/GLTFLoader.js"
        }
    }
    </script>

      <script id="vertexShader" type="x-shader/x-vertex">
    precision highp float;

    uniform float sineTime;
    uniform float time;

    uniform vec3 cameraPos;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    attribute vec3 position;
    attribute vec3 offset;
    attribute vec4 color;
    attribute vec4 orientationStart;
    attribute vec4 orientationEnd;

    varying vec3 vPosition;
    varying vec4 vColor;

    vec3 quat_transform(vec4 q, vec3 v) {
      return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
    }

    void main(){

      float size = 500000.0;
      vPosition = offset;
      vPosition.x += floor((cameraPos.x-vPosition.x)/size + 0.5)*size;
      vPosition.y += floor((cameraPos.y-vPosition.y)/size + 0.5)*size;
      vPosition.z += floor((cameraPos.z-vPosition.z)/size + 0.5)*size;

      //vec4 orientation = normalize( mix( orientationStart, orientationEnd, abs(0.5+(time*0.5)) ) );
      vec4 orientation = orientationStart;
      vPosition = vPosition + quat_transform(orientation,position);
      //cool Effect vPosition = offset + quat_transform(orientationStart,position);
      // cool effect vPosition.x += vPosition.x-cameraPos.x;




      vec3 vcV = cross( orientation.xyz, vPosition );


      vColor = color;

      gl_Position = projectionMatrix * modelViewMatrix * vec4( vPosition, 1.0 );

    }

  </script>

  <script id="fragmentShader" type="x-shader/x-fragment">

    precision highp float;

    uniform float time;

    varying vec3 vPosition;
    varying vec4 vColor;

    void main() {

      vec4 color = vec4( vColor );
      //color.r += sin( 1.0 * time  + 3.14) * 1200.5;
      color.r = time;

      gl_FragColor = color;

    }

  </script>

    <script type="module">


      // import * as THREE from 'https://unpkg.com/three@0.178.0/build/three.module.js';
      // import * as three from 'https://unpkg.com/three@0.178.0/build/three.module.js';


      // import * as CopyShader from 'https://unpkg.com/three@0.178.0/examples/jsm/shaders/CopyShader.js';
      // // import * as ShaderPass from 'https://unpkg.com/three@0.178.0/examples/jsm/postprocessing/ShaderPass.js';
      // import * as EffectComposer from 'https://unpkg.com/three@0.178.0/examples/jsm/postprocessing/EffectComposer.js';
      // // import { RenderPass } from 'https://unpkg.com/three@0.178.0/examples/jsm/postprocessing/RenderPass.js';
      // // import { OutlinePass } from 'https://unpkg.com/three@0.178.0/examples/jsm/postprocessing/OutlinePass.js';
      // // import { OutputPass } from 'https://unpkg.com/three@0.178.0/examples/jsm/postprocessing/OutputPass.js';


        import * as THREE from 'three';
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
        import { OutlinePass } from 'three/examples/jsm/postprocessing/OutlinePass.js';
        import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';
        import { FXAAShader } from 'three/examples/jsm/shaders/FXAAShader.js';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';




let Height = window.innerWidth >window.innerHeight?window.innerHeight:window.innerWidth
let Width = window.innerWidth >window.innerHeight?window.innerWidth:window.innerHeight

let mouseX = Width/2
let mouseY = Height/2

// onmousemove = (e)=>{mouseX = (e.clientX); mouseY = (e.clientY)}
document.addEventListener("mousemove",(e)=>{
  mouseX = e.clientX
  mouseY = e.clientY


})

let div = document.createElement("div")
div.style.position="absolute"
div.style.color="white"
div.style.backgroundColor="rgba(0,255,0,0.1)"
div.style.zIndex="500"
div.style.top="0px"
div.style.left="0px"
div.id = "debugdiv"
div.style.width = "50%"
div.style.height = "50%"

document.body.appendChild(div)

class LCanvas{ //lopkns template canvas
  constructor(w=100,h=100,id=("LCanvas-"+Math.random())){
    this.canvas = document.createElement("canvas")
    this.canvas.id = id
    this.ctx = this.canvas.getContext("2d")
    this.canvas.style.position = "absolute"
    this.canvas.style.top = "0px"
    this.canvas.style.left = "0px"
    this.canvas.zIndex = "1500"
    this.canvas.width = w
    this.canvas.height = h
    this.ctx.fillStyle = "black"
    this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height)
    document.body.appendChild(this.canvas)
    return(this)
  }

  fitScreenSize(){
    this.canvas.width = window.innerWidth
    this.canvas.height = window.innerHeight
  }

  clear(){
    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)
  }

  oneTimeDown(f){ // pass in a function for what to do with one click
    this.canvas.addEventListener("mousedown",f,{once:true})
  }

  getPixelRGB(x,y){
    let d = this.ctx.getImageData(x, y, 1, 1).data
    return(d)
  }


}

var light

class ENV{
  static targetFPS = 60
  static airFriction = 0.9995
  static grav = 9.81/this.targetFPS*7 

  static timeWarp = 1

  static paused = false

  static update(dt){
    this.timeWarp = this.timeWarp ** (0.99**dt)
    if(this.paused){this.timeWarp = 0;}
    DRONE.light.color.r = this.timeWarp
    DRONE.light.color.g = this.timeWarp
  }

}
    var downs = {}

const raycaster = new THREE.Raycaster();


class DRONE{
  static vel = new THREE.Vector3(0,0,0)

  static controls = {
    "up":0,
    "pitch":0,
    "roll":0,
    "yaw":0
  }

  static forces = {
    "up":0,
    "pitch":0,
    "roll":0,
    "yaw":0
  }

  static controlSpeed = 0.0008
  static rollControlSpeed = 1
  static controlStrength = 0.0009

  static invertedControls = 1

  static forwardLocked = true

  static updatePos(dt=1){


      if(!this.forwardLocked){
        if(downs.w){
          DRONE.controls.pitch += this.controlSpeed * this.invertedControls * dt
          // DRONE.forces.up += this.controlSpeed * 345/4
        }  if(downs.s){
          DRONE.controls.pitch -= this.controlSpeed* this.invertedControls * dt
          // DRONE.forces.up -= this.controlSpeed * 345/4
        } if(downs.a){
          DRONE.controls.yaw += this.controlSpeed* dt
        }  if(downs.d){
          DRONE.controls.yaw -= this.controlSpeed* dt
        }  if(downs.e){
          DRONE.controls.roll -= this.controlSpeed* dt
        }  if(downs.q){
          DRONE.controls.roll += this.controlSpeed* dt
        } if(downs[" "]){
        ENV.timeWarp *= 0.97
          // DRONE.forces.up += this.controlSpeed * 345/4
        } if(downs.Control){
          DRONE.forces.up -= this.controlSpeed * 345/4
        }
      } else {
        if(downs[" "]){
          DRONE.vel.add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(2*dt))
        }
        
        if(downs["M0"]){
          DRONE.vel.add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(1*dt))
        }
      }

      if(downs["`"]){
        // ENV.timeWarp *= 0.97
      }

    div.innerText = JSON.stringify(this.forces)


    this.controls.yaw *= 0.995** dt
    this.controls.pitch *= 0.995** dt
    this.controls.up *= 0.95** dt

    this.controls.up = (Height/2-mouseY)*0.005 / Height * 1500


    // this.forces.roll = Math.sqrt(Math.abs((Width/2-mouseX)*0.000001))*((Width/2-mouseX)<0?-1:1)
    // this.forces.pitch = ((Height/2-mouseY)*0.00007)

    this.controls.roll = ((Width/2-mouseX)*0.00007) * this.rollControlSpeed / Width * 2000


    Object.keys(this.controls).forEach((e)=>{
      if(e==="up"){this.forces[e] = this.controls[e];return}
      let mns = this.controls[e]-this.forces[e]
      this.forces[e] += Math.min(Math.abs(mns),this.controlStrength+Math.abs(mns/100)) * Math.sign(mns) * dt
    })

    camera.rotateY(this.forces.yaw* dt)
    camera.rotateZ(this.forces.roll* dt)
    camera.rotateX(this.forces.pitch* dt)


    this.upVector = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion)
    this.angleUp = this.upVector.angleTo(new THREE.Vector3(0,1,0))
    this.vel.add(this.upVector.clone().multiplyScalar(this.forces.up*dt))

    this.vel.y -= ENV.grav * dt


    this.vel.multiplyScalar(ENV.airFriction** dt)
    this.speed = DRONE.vel.length()
    this.dPos = this.vel.clone().multiplyScalar(dt)

    this.dst = Infinity
    const intersects = raycaster.intersectObjects( world.activeMeshes );
    if(intersects.length>0){
      div.innerText += "\n INTERSECTS \n"
      this.dst = intersects[0].distance
      if(this.dst < DRONE.dPos.length()){
        // div.style.backgroundColor = "red"
        DRONE.forces.roll += minMax(-2,(Math.random()-0.5)*0.0025*DRONE.speed,2)
        DRONE.forces.yaw += minMax(-2,(Math.random()-0.5)*0.0025*DRONE.speed,2)
        DRONE.vel.multiplyScalar(0.8)
        DRONE.forwardLocked = false
        console.log("HIT")
      }
    }

    camera.position.add(this.dPos)
    if(camera.position.y < -100000){
      this.reset()
    }
    light.position.set(camera.position.x,camera.position.y,camera.position.z)
    raycaster.set(camera.position,this.vel.clone().normalize())
    // raycaster.set(camera.position,camera.getWorldDirection(new THREE.Vector3))
    this.lookingTowards = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(1200)



    if(this.topHemisphere.position){

      this.topHemisphere.position.set(camera.position.x,camera.position.y,camera.position.z)
      this.topHemisphere.position.add(this.lookingTowards)
      this.topHemisphere.position.add(new THREE.Vector3(-0,-600,0).applyQuaternion(camera.quaternion))

      this.bottomHemisphere.position.set(camera.position.x,camera.position.y,camera.position.z)
      this.bottomHemisphere.position.add(this.lookingTowards)
      this.bottomHemisphere.position.add(new THREE.Vector3(-0,-600,0).applyQuaternion(camera.quaternion))

    }

    world.autogen()

    this.calcWorldPos()

    this.scoring(dt)


    div.innerText += JSON.stringify(this.vel)
  }


  static getInfo(){
    this.stableYlevel = Height/2 - ENV.grav / 1500 * Height / 0.005
  }

  static scoring(dt){
    if(world.worldbox.y/2 > camera.position.y && camera.position.y > -world.worldbox.y/2 && world.worldbox.z/2 > camera.position.z && camera.position.z > -world.worldbox.z/2 && camera.position.x > this.furthestOut && this.vel.x > 3){

      this.score += dt * this.speed**2 /* Math.min(1/distance(0,0,camera.position.y,camera.position.z),1) */ /400000
      this.furthestOut = camera.position.x 
    } 
  }
  static calcWorldPos(){


    if(!world.loadeds[this.worldPos]){debugger}

    while(camera.position.x > world.loadeds[this.worldPos].userData.end){
      this.worldPos += 1

      if(!world.loadeds[this.worldPos].userData.noCheckpoint){
        this.checkpointId = this.worldPos
        console.log("CHECKPOINT")
      }
    }
    while(camera.position.x < world.loadeds[this.worldPos].userData.start){
      this.worldPos -= 1
      if(!world.loadeds[this.worldPos].userData.noCheckpoint){ // bug
        this.checkpointId = this.worldPos
      }
    }

    this.start = world.loadeds[this.worldPos].userData.start
    this.end = world.loadeds[this.worldPos].userData.end
  }
    
  static checkpointId = 1

  static reset(){
    console.log("reset")


    this.worldPos = this.checkpointId

    this.controls = {
      "up":0,
      "pitch":0,
      "roll":0,
      "yaw":0
    }

    this.forces = {
      "up":0,
      "pitch":0,
      "roll":0,
      "yaw":0
    }

    this.furthestOut = 0

    this.forwardLocked = true
    this.vel = new THREE.Vector3(0,0,0)
    this.score = 0;
    camera.position.z = 0;
    camera.position.y = 0;
    camera.position.x = -21200;
    // camera.position.x = 0

    camera.rotation.set(0,Math.PI*3/2,0)

    world.recalculate()
    world.loadChunk({id:this.checkpointId})
    world.recalculate()
    camera.position.x = world.loadeds[this.checkpointId].userData.start - 21200
    world.autogen()

    this.calcWorldPos()


    this.getInfo()

  }

}
window.drone = DRONE

class world{
  static worldbox = {"y":2*20000,"z":2*20000}
  static activeMeshes = []
  static loadeds = {}
  static seed = "welcome"

  static rng = new Math.seedrandom(this.seed)

  static levelDesign = {}


  static autogen(){
    // this.recalculate()

    let pStart = camera.position.x - DRONE.light.distance*2 
    let pEnd = camera.position.x + DRONE.light.distance*2 

    // if(DRONE.vel.x >= 0){
      //delete meshes first
      this.removeBehind(pStart)
      this.removeForward(pEnd)

      let i = 15
      while(pEnd > this.end){
        i--
        // if(i<1){
        //   console.log("BOMBBBBBBBB!!!")
        //   this.activeMeshes.sort((a,b)=>{return(a.userData.id - b.userData.id)})
        //   this.recalculate()
        // }
        if(i < 0){debugger}
        console.log("jhey1"+ pEnd + "," + this.end)
        this.loadChunk({id: this.endMesh.userData.id+1})
      }
      while(pStart < this.start){
        console.log("jhey")
        this.loadChunk({id: this.startMesh.userData.id-1, reverse:true})
      }


  }

  static preloadChunk(dict){
    if(this.levelDesign[dict.id]){return}
    this.levelDesign[dict.id] = dict
  }

  static loadChunk(dict){
    if(this.loadeds[dict.id]){console.log("already loaded: "+dict.id);return}
    if(this.levelDesign[dict.id]){
      this.generate(this.levelDesign[dict.id])
    } else {
      this.levelDesign[dict.id] = dict
      this.generate(dict)
      dict.fullyLoaded = true
    }
  }


  static recalculate(){

    if(this.activeMeshes.length === 0){
      this.startMesh = {userData:{id:0}}
      this.endMesh = {userData:{id:0}}
      this.start = camera.position.x+21200
      this.end = camera.position.x+21200
      console.log("DEFAULTED RECALC:" + camera.position.x)
      return
    }

    this.startMesh = this.activeMeshes[0]
    this.endMesh = this.activeMeshes[this.activeMeshes.length-1]
    this.start = this.startMesh.userData.start
    this.end = this.endMesh.userData.end
  }


  // static generate(level,length=2000000,count=20000){
  static generate({level=0,length=200000,count=20000,id=1,reverse=false,startPos=undefined} = {}){




    let rng = new Math.seedrandom(this.seed+id)
    if(startPos === undefined){
      if(reverse){
        startPos = this.start - length
      } else {
        startPos = this.end
      }
    this.levelDesign[id].startPos = startPos
    }



    // console.log("GENERATE")


    count = Math.floor(count)
    let mesh;
    if(level === 0){
      let per = 10000
      let count = Math.floor(length/10000)*4

      var geometry = new THREE.BoxGeometry(4200, 1200, 1200);
      var materials = new THREE.MeshStandardMaterial({ color: "#FF3030", roughness:0, metalness: 0.8})

      mesh = new THREE.InstancedMesh( geometry, materials, count );
      mesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // will be updated every frame
      scene.add(mesh);

      let dummy = new THREE.Object3D()
      for ( let i = 0; i < count; i ++) {
          let [x,y,z] = [Math.floor(i/4)*per+startPos, world.worldbox.y*0.8 * (i%2-0.5), world.worldbox.z*0.8 * (Math.floor(i%4/2)-0.5)];
          dummy.rotation.set(Math.PI/4,0,0)
          dummy.position.set(x,y,z);
          dummy.updateMatrix();
          mesh.setMatrixAt( i, dummy.matrix );
      }
      mesh.name = "spaceRail"

      mesh.userData.decorations = [this.border(startPos,length)] 
      mesh.userData.noCheckpoint = true

    }

    if(level === 1){


      this.preloadChunk({id:id+1,level:0})
      this.preloadChunk({id:id+2,level:2,length:2000000})


      var geometry = new THREE.BoxGeometry(200, 200, 200);



      var materials = [
        new THREE.MeshStandardMaterial({ color: "#AA5555" /*, depthTest:false*/}),
        new THREE.MeshStandardMaterial({ color: "#55AA55" }),
        new THREE.MeshStandardMaterial({ color: "#AAAAFF" }),
        new THREE.MeshStandardMaterial({ color: "#AAFFFF" }),
        new THREE.MeshStandardMaterial({ color: "#FFAAFF" }),
        new THREE.MeshStandardMaterial({ color: "#FFFFAA" })
      ];
      mesh = new THREE.InstancedMesh( geometry, materials, count );
      mesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // will be updated every frame
      scene.add(mesh);

      let dummy = new THREE.Object3D()

      for ( let i = 0; i < count; i ++ ) {
        let mr = rng()
          let [x,y,z] = [mr*length+startPos, ranRange(world.worldbox.y), ranRange(world.worldbox.z)];
          dummy.position.set(x,y,z);
          dummy.rotation.set(rng()*Math.PI*mr,rng()*Math.PI*mr,rng()*Math.PI*mr)
          dummy.scale.set( 1 + Math.abs(normalRandom(1,3,rng)), 1 + Math.abs(normalRandom(1,3,rng)), 1 + Math.abs(normalRandom(1,3,rng)) );
          dummy.updateMatrix();
          mesh.setMatrixAt( i, dummy.matrix );
      }

      mesh.name = "level1"
      mesh.userData.decorations = [this.border(startPos,length)] 
    }

    if(level === 2){

      this.preloadChunk({id:id+1,level:0})
      this.preloadChunk({id:id+2,level:3,length:2000000})

      var geometry = new THREE.BoxGeometry(800, 200, 200);
      var materials = [
        new THREE.MeshStandardMaterial({ color: "#55AA55" /*, depthTest:false*/}),
        new THREE.MeshStandardMaterial({ color: "#55AA55" }),
        new THREE.MeshStandardMaterial({ color: "#AAAAFF" }),
        new THREE.MeshStandardMaterial({ color: "#AAFFFF" }),
        new THREE.MeshStandardMaterial({ color: "#55AA55" }),
        new THREE.MeshStandardMaterial({ color: "#55AA55" })
      ];
      mesh = new THREE.InstancedMesh( geometry, materials, count );
      mesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // will be updated every frame
      scene.add(mesh);

      let dummy = new THREE.Object3D()

      for ( let i = 0; i < count; i ++ ) {
        let mr = rng()
          let [x,y,z] = [mr*length+startPos, ranRange(world.worldbox.y), ranRange(world.worldbox.z)];
          dummy.position.set(x,y,z);
          dummy.rotation.set((rng()-0.5)*Math.PI*mr,(rng()-0.5)*Math.PI*mr,(rng()-0.5)*Math.PI*mr)
          dummy.scale.set( 1 + Math.abs(normalRandom(1,6,rng)), 1 + Math.abs(normalRandom(1,3,rng)), 1 + Math.abs(normalRandom(1,3,rng)) );
          dummy.updateMatrix();
          mesh.setMatrixAt( i, dummy.matrix );
      }

      mesh.userData.decorations = [this.border(startPos,length)] // NEED TO CLEAR THIS SHIT AFTER
    }


    if(level === 3){

      this.preloadChunk({id:id+1,level:0})
      this.preloadChunk({id:id+2,level:4,length:2000000})

      count = Math.floor(count*2/3)


      var geometry = new THREE.TetrahedronGeometry(300);
      var materials = new THREE.MeshStandardMaterial({ color: "#F5BE27" /*, depthTest:false*/})
      mesh = new THREE.InstancedMesh( geometry, materials, count );
      mesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // will be updated every frame
      scene.add(mesh);

      let dummy = new THREE.Object3D()

      for ( let i = 0; i < count; i ++ ) {
        let mr = rng()
          let [x,y,z] = [mr*length+startPos, ranRange(world.worldbox.y), ranRange(world.worldbox.z)];
          dummy.position.set(x,y,z);
          dummy.rotation.set((rng()-0.5)*Math.PI,(rng()-0.5)*Math.PI,(rng()-0.5)*Math.PI)
          let mr2 = 1 + Math.abs(normalRandom(1,4,rng))
          dummy.scale.set( mr2, mr2, mr2 );
          dummy.updateMatrix();
          mesh.setMatrixAt( i, dummy.matrix );
      }

      mesh.userData.decorations = [this.border(startPos,length)] // NEED TO CLEAR THIS SHIT AFTER
    }
    if(level === 4){

      count = Math.floor(count/5)

      this.preloadChunk({id:id+1,level:0})
      this.preloadChunk({id:id+2,level:3,length:2000000})

      var geometry = new THREE.BoxGeometry(800, 200, 200);
      var materials = [
        new THREE.MeshStandardMaterial({ color: "#55AA55" /*, depthTest:false*/}),
        new THREE.MeshStandardMaterial({ color: "#55AA55" }),
        new THREE.MeshStandardMaterial({ color: "#AAAAFF" }),
        new THREE.MeshStandardMaterial({ color: "#AAFFFF" }),
        new THREE.MeshStandardMaterial({ color: "#55AA55" }),
        new THREE.MeshStandardMaterial({ color: "#55AA55" })
      ];
      geometry = window.loadedGeom.geometry
      materials = window.loadedGeom.material
      mesh = new THREE.InstancedMesh( geometry, materials, count );
      mesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // will be updated every frame
      scene.add(mesh);

      let dummy = new THREE.Object3D()

      for ( let i = 0; i < count; i ++ ) {
        let mr = rng()
          let [x,y] = [mr*length+startPos, -world.worldbox.y/1.5];
          let z = Math.abs(ranRange(world.worldbox.z**2))**0.5 * Math.sign(rng()-0.5)
          dummy.position.set(x,y,z);
          dummy.rotation.set((rng()-0.5)*Math.PI*mr /5,(rng()-0.5)*Math.PI*mr /5,(rng()-0.5)*Math.PI*mr /5)
          // dummy.scale.set( 1 + Math.abs(normalRandom(1,6,rng)), 1 + Math.abs(normalRandom(1,3,rng)), 1 + Math.abs(normalRandom(1,3,rng)) );
          dummy.scale.set(1000 + Math.abs(normalRandom(0,600,rng)),Math.abs(z) + 2000 * Math.abs(normalRandom(1,10*mr,rng)) ,1000 + Math.abs(normalRandom(0,600,rng)));
          dummy.updateMatrix();
          mesh.setMatrixAt( i, dummy.matrix );
      }

      mesh.userData.decorations = [this.border(startPos,length)] // NEED TO CLEAR THIS SHIT AFTER
    }
















    let midpt = startPos + length/2
    if(id > this.endMesh.userData.id || this.activeMeshes.length===0){
      this.activeMeshes.push(mesh)
      console.log("PUSHED: "+id+ " at "+startPos+" with world: "+ this.start + "-"+this.end + ", camera at:"+camera.position.x+", reverse: "+reverse)
    } else if(id < this.startMesh.userData.id){
      this.activeMeshes.splice(0,0,mesh)
      console.log("SPLICED: "+id+ " at "+startPos+" with world: "+ this.start + "-"+this.end + ", camera at:"+camera.position.x+ ", reverse: "+reverse)
    } else {
      console.log("dont know what to do");
      debugger;
    }


    // console.log("GENERATE DONE")

      mesh.userData.start = startPos
      mesh.userData.end = startPos + length

    mesh.userData.id = id
    console.log("ID "+id)

    this.loadeds[id] = mesh

    this.recalculate()

    return(mesh)
  }


  static border(startPos,length,per=4000){
      let material = new THREE.MeshPhysicalMaterial({color:"#00FFFF",metalness:0.7,roughness:1,reflectivity:1})
      var geometry = new THREE.BoxGeometry(2000, 150, 150);

      let count = Math.floor(length/per)*4

      let mesh = new THREE.InstancedMesh( geometry, material, count)
      mesh.instanceMatrix.setUsage( THREE.StaticDrawUsage ); // will be updated every frame
      scene.add(mesh);

      let dummy = new THREE.Object3D()
      for ( let i = 0; i < count; i ++ ) {
          let [x,y,z] = [Math.floor(i/4)*per+startPos, world.worldbox.y * (i%2-0.5), world.worldbox.z * (Math.floor(i%4/2)-0.5)];
          dummy.position.set(x,y,z);
          dummy.updateMatrix();
          mesh.setMatrixAt( i, dummy.matrix );
      }
      mesh.name = "border1"
      return(mesh)
  }


  static removeBehind(start){
    let meshes = []
    while(this.activeMeshes.length > 0){
      if(start > this.activeMeshes[0].userData.end){
        let msh = this.activeMeshes.splice(0,1)[0]
        meshes.push(msh)
        console.log("removed behind:" + msh.userData.id)
        continue;
      }
      break;
    }
    if(meshes.length===0){return}
    this.remove(meshes)
  }
  static removeForward(end){
    let meshes = []
    while(this.activeMeshes.length > 0){
      if(end < this.activeMeshes[this.activeMeshes.length-1].userData.start){
        meshes.push(this.activeMeshes.pop())
        console.log("removed forward")
        continue;
      }
      break;
    }
    if(meshes.length===0){return}
    this.remove(meshes)
  }

  static remove(meshes){
    // console.log("removing:"+meshes)
    while(meshes.length>0){
      let mesh = meshes.splice(0,1)[0];
      if(mesh.userData.id!==undefined){
        this.loadeds[mesh.userData.id] = false
        // console.log(mesh.name,mesh.userData.id)
      } else {
        // console.log("not found ",mesh.name,JSON.stringify(mesh.userData))
      }
      scene.remove(mesh)
      if(mesh.userData.decorations){
        meshes.push(...mesh.userData.decorations)
      }
      mesh.geometry.dispose();
    }
    this.recalculate()
  }

}
window.world = world



var sensors = {
  Orientation_a:0,
  Orientation_b:0,
  Orientation_g:0
}
var camera, scene, renderer;
var mesh2;



function ranRange(x,rng=world.rng){
  return(rng()*x-x*0.5)
}

function ran(x){
  return(Math.random()*x)
}



function init() {
  window.camera = camera = new THREE.PerspectiveCamera(
    70,
    window.innerWidth / window.innerHeight,
    1,
    10000000,
  );
    

  // camera.position.z = 2
  // camera.position.x = 0
  // camera.position.y = 0

  window.scene = scene = new THREE.Scene();

  window.renderer = renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);

  document.body.appendChild(renderer.domElement);







  DRONE.topHemisphere = new THREE.Mesh(new THREE.SphereGeometry( 140, 20, 20, 0, Math.PI, 0, Math.PI ),new THREE.MeshStandardMaterial({ color: "#33AAFF" }))
  DRONE.topHemisphere.name = "topHem"
  DRONE.bottomHemisphere = new THREE.Mesh(new THREE.SphereGeometry( 140, 20, 20, Math.PI, Math.PI,0, Math.PI ),new THREE.MeshStandardMaterial({ color: "#FF3300" }))
  DRONE.bottomHemisphere.name = "bottomHem"



  DRONE.topHemisphere.rotateX(Math.PI*3/2)
  DRONE.topHemisphere.renderOrder = 998
  DRONE.topHemisphere.material.depthTest = false;
  DRONE.bottomHemisphere.renderOrder = 999
  DRONE.bottomHemisphere.rotateX(Math.PI*3/2)
  // DRONE.topHemisphere.rotateY(Math.atan(1/2))
  // DRONE.bottomHemisphere.rotateY(Math.atan(1/2))
  DRONE.bottomHemisphere.material.depthTest = false;





        const loader = new GLTFLoader();

      // let geometry;

      loader.load( '../three/source/s_building2.gltf', function ( gltf ) {

        let model = gltf.scene
        gltf.scene.position.y = 0
        gltf.scene.position.z = 0
        gltf.scene.position.x = 200
        // gltf.scene.scale.multiplyScalar(5)
        // let mesh3 = new THREE.Mesh(
        // new THREE.BoxGeometry(30,170,30),
        // new THREE.MeshStandardMaterial({ color: 0xffffff }))

        // mesh3.position.z = gltf.scene.position.z
        // mesh3.position.y = gltf.scene.position.y
        // mesh3.position.x = gltf.scene.position.x + 50

         // let bbox = new THREE.Box3().setFromObject(model);
         //    let helper = new THREE.Box3Helper(bbox, new THREE.Color(0, 255, 0));
         //    let size = bbox.getSize(new THREE.Vector3());
         //    console.log(size)

        gltf.scene.rotateX(1.2368643351396535)
        gltf.scene.rotateY(0.4719777676633856)
        gltf.scene.rotateZ(-0.918989255293726)



        console.log(gltf.scene)

        window.loadedGeom = gltf.scene.children[0]

      // scene.add( gltf.scene );

      


    }, undefined, function ( error ) {

      console.error( error );

    } );






  // var materials = new THREE.MeshStandardMaterial({ color: 0xffff00 })

  // mesh = new THREE.Mesh(geometry, materials);

  DRONE.light = light = new THREE.PointLight( 0xffffff, 300, 100000 , 0.5 );
  light.position.set( 50, 50, 50 );
  scene.add( light );

  world.recalculate()
  world.loadChunk({id:1,level:1,length:2000000})
  DRONE.reset()



  let count = Math.floor(21400)

  const vector = new THREE.Vector4();
  const positions = [];
  const offsets = [];
  const colors = [];
  const orientationsStart = [];
  const orientationsEnd = [];

  let size = 225

  positions.push( 0, -size*2, 0 );
  positions.push( 0, size*2, 0 );
  positions.push( 0, size, size );




  let galazyBoxSize = 500000

  for ( let i = 0; i < count; i ++ ) {

      // offsets
      let [x,y,z] = [Math.random()*galazyBoxSize, Math.random()*galazyBoxSize, Math.random()*galazyBoxSize];
      // [x,y,z] = [136*Math.random()*20000, 2*Math.random()*20000, 2*Math.random()*20000];
      offsets.push(x,y,z);
      // offsets.push( Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 );
      // colors
      colors.push( Math.random(), Math.random(), Math.random(),1);
      // colors.push( Math.random(), Math.random(), Math.random(), Math.random() );
      // orientation start
      vector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );
      vector.normalize();
      orientationsStart.push( vector.x, vector.y, vector.z, vector.w );
      // orientation end
      vector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );
      vector.normalize();
      orientationsEnd.push( vector.x, vector.y, vector.z, vector.w );
  }

  // mesh.instanceMatrix.needsUpdate = true


const geometry2 = new THREE.InstancedBufferGeometry();

geometry2.instanceCount = count; // set so its initialized for dat.GUI, will be set in first draw otherwise
geometry2.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
geometry2.setAttribute( 'offset', new THREE.InstancedBufferAttribute( new Float32Array( offsets ), 3 ) );
geometry2.setAttribute( 'color', new THREE.InstancedBufferAttribute( new Float32Array( colors ), 4 ) );
geometry2.setAttribute( 'orientationStart', new THREE.InstancedBufferAttribute( new Float32Array( orientationsStart ), 4 ) );
geometry2.setAttribute( 'orientationEnd', new THREE.InstancedBufferAttribute( new Float32Array( orientationsEnd ), 4 ) );



// const mesh2 = new THREE.Mesh( geometry2, new THREE.MeshStandardMaterial({color : 0xffffff }) );
mesh2 = new THREE.Mesh(geometry2, new THREE.RawShaderMaterial( {

  uniforms: {
    'time': { value: 1.0 },
    'sineTime': { value: 1.0 },
    'cameraPos': { value: camera.position },
  },
  vertexShader: document.getElementById( 'vertexShader' ).textContent,
  fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
  side: THREE.DoubleSide,
  forceSinglePass: true,
  transparent: false

} ))
geometry2.computeBoundingSphere()
geometry2.boundingSphere.radius = Infinity
window.gem = geometry2
mesh2.name = "starcloud"
scene.add( mesh2 );


window.mesh2 = mesh2





  window.addEventListener("resize", onWindowResize, false);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  canvas.fitScreenSize()

  Height = window.innerWidth >window.innerHeight?window.innerHeight:window.innerWidth
  Width = window.innerWidth >window.innerHeight?window.innerWidth:window.innerHeight

  renderer.setSize(window.innerWidth, window.innerHeight);
}



// var composer





    var canvas = new LCanvas(Width,Height)

    canvas.canvas.style.cursor = "none"


var startDate = Date.now()
var lastDate = Date.now()

function minMax(a,b,c){
  return(Math.min(Math.max(a,b),c))
}

function animate(){
  requestAnimationFrame(animate)

  let dt = Date.now()-lastDate
  lastDate = Date.now()
  if(DRONE){
    DRONE.updatePos(dt/16 * ENV.timeWarp)
    ENV.update(dt/16)  
  }


  // mesh.rotation.y = Date.now()/1000

  mesh2.material.uniforms['time'].value = Math.sin((Date.now()-startDate) * 0.0005);
  // renderer.autoClear = false
  // renderer.clear();
  // renderer.render(DRONE.topHemisphere,camera)
  // renderer.clearDepth();

  renderer.render(scene, camera);

  let ctx = canvas.ctx


  // DRONE.vel.y += 20

  ctx.clearRect(0,0,Width,Height)
  ctx.beginPath()
  let speedMeter = Math.min(DRONE.speed/300,3)
  ctx.arc(Width/2,Height/2,Height/3*2,Math.PI/2*3-speedMeter-0.5,Math.PI/2*3+speedMeter+0.5)
  let dvy = minMax(-255,DRONE.vel.y,255)
  ctx.strokeStyle = "rgba("+Math.floor(-dvy)+","+Math.floor(255+dvy)+","+Math.floor(dvy)+","+0.5+")"
  ctx.lineWidth = 25;
  ctx.stroke()

  if(DRONE.speed>400){
    speedMeter = Math.min((DRONE.speed-400)/400,3)
    ctx.beginPath()
    ctx.arc(Width/2,Height/2,Height/3*2+45,Math.PI/2*3-speedMeter-0.5,Math.PI/2*3+speedMeter+0.5)
    let dvy = minMax(-255,DRONE.vel.y*3,255)
    ctx.strokeStyle = "rgba("+(-dvy)+","+(255+dvy)+","+dvy+","+0.5+")"
    ctx.lineWidth = 25;
    ctx.stroke()

    let Wspd = DRONE.speed-900
    let i = 2
    while(Wspd>0){
    speedMeter = Math.min((Wspd)/400,3)
    ctx.beginPath()
    ctx.arc(Width/2,Height/2,Height/3*2+45*i,Math.PI/2*3-speedMeter-0.5,Math.PI/2*3+speedMeter+0.5)
    let dvy = minMax(-255,DRONE.vel.y*(3+i),255)
    ctx.strokeStyle = "rgba("+(-dvy)+","+(255+dvy)+","+dvy+","+0.5+")"
    ctx.lineWidth = 25;
    ctx.stroke()
    i++
      Wspd -= 400
    }

  }



  if(DRONE.dst !== Infinity){
  let impactMarker = Math.min(Math.max(DRONE.dst/DRONE.speed/50,0),0.5)
  const impactGradient = ctx.createLinearGradient(0, 0, Width, 0);
    impactGradient.addColorStop(0, "rgba(255,0,0,0.5)");
    impactGradient.addColorStop(0.5-impactMarker, "rgba(255,0,0,0)");
    impactGradient.addColorStop(0.5+impactMarker, "rgba(255,0,0,0)");
    impactGradient.addColorStop(1, "rgba(255,0,0,0.5)");
    ctx.fillStyle = impactGradient
    ctx.fillRect(0,0,Width,Height)
  }


  const gradient = ctx.createLinearGradient(0, 0, Width, 0);



    // Add three color stops
    // gradient.addColorStop(0.4, "rgba(255,0,0,0.5)");
    // gradient.addColorStop(0.5, "rgba(0,255,0,0.5)");
    // gradient.addColorStop(0.6, "rgba(255,0,0,0.5)");

    gradient.addColorStop(0, "rgba(0,255,0,0.5)");
    gradient.addColorStop(0.1, "rgba(255,0,0,0.5)");
    gradient.addColorStop(0.9, "rgba(255,0,0,0.5)");
    gradient.addColorStop(1, "rgba(0,255,0,0.5)");

    let yawDraw = minMax(-Width/4,DRONE.forces.yaw*Width*2,Width/4)

  ctx.beginPath()
  ctx.moveTo(Width,Height/2-20)
  ctx.lineTo(Width - yawDraw ,Height/2-20)
  ctx.moveTo(0,Height/2-20)
  ctx.lineTo(0 - yawDraw ,Height/2-20)
    ctx.moveTo(Width,Height/2+40)
  ctx.lineTo(Width - yawDraw ,Height/2+40)
  ctx.moveTo(0,Height/2+40)
  ctx.lineTo(0 - yawDraw ,Height/2+40)
  ctx.lineWidth = 25;
  // ctx.strokeStyle = "rgba("+(-DRONE.vel.y)+","+(255+DRONE.vel.y)+","+DRONE.vel.y+","+0.7+")"
  ctx.strokeStyle = gradient
  ctx.stroke()

  ctx.beginPath()
  ctx.moveTo(Width/2,Height/4)
  ctx.lineTo(Width/2,Height/1.8)
  ctx.lineWidth = 2;
  // ctx.strokeStyle = "rgba("+(-DRONE.vel.y)+","+(255+DRONE.vel.y)+","+DRONE.vel.y+","+0.7+")"
  ctx.strokeStyle = "rgba(100,0,0,0.5)"
  ctx.stroke()

  ctx.beginPath() // red cross
  ctx.moveTo(Width/2-20,Height/2)
  ctx.lineTo(Width/2+20,Height/2)
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(100,0,0,0.5)"
  ctx.stroke()

  ctx.beginPath() // level cross
  ctx.moveTo(Width/2-40,DRONE.stableYlevel)
  ctx.lineTo(Width/2+40,DRONE.stableYlevel)
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(0,160,160,0.8)"
  ctx.stroke()

  let dynamicStableYlevel = Height/2 - (ENV.grav / 1287 * Height / 0.005) / Math.cos(DRONE.angleUp)
  if(isFinite(dynamicStableYlevel)){
    ctx.beginPath() // level cross dynamic
    ctx.moveTo(Width/2-40,dynamicStableYlevel)
    ctx.lineTo(Width/2+40,dynamicStableYlevel)
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(0,200,0,0.5)"
    ctx.stroke()
  }


  ctx.fillStyle = "pink"
  ctx.fillRect(mouseX-5,mouseY-5,10,10)


  ctx.fillStyle = DRONE.forwardLocked?"orange":"red"
  ctx.font = "30px Arial"
  ctx.fillText(DRONE.forwardLocked?"Cruise mode: hold space to accelerate":"Manual mode: WASD to navigate",0,Height)
  ctx.font = "50px Arial"
  ctx.fillText(Math.floor(DRONE.score),0,Height-35)

}

init();
animate();

function updateRotation(pitch, roll, yaw) {

 const quaternionYaw = new THREE.Quaternion().setFromAxisAngle(
      new THREE.Vector3(0, 1, 0), // Y-axis
      yaw
    );
    const quaternionPitch = new THREE.Quaternion().setFromAxisAngle(
      new THREE.Vector3(1, 0, 0), // X-axis
      pitch
    );
    const quaternionRoll = new THREE.Quaternion().setFromAxisAngle(
      new THREE.Vector3(0, 0, 1), // Z-axis
      -roll
    );
  
    // Combine the quaternions: Yaw * Pitch * Roll
    const deviceQuaternion = new THREE.Quaternion()
      .multiply(quaternionYaw)
      .multiply(quaternionPitch)
      .multiply(quaternionRoll);
  
    // Reference Quaternion: Rotate -90 degrees around X-axis to align device frame with Three.js frame
    const referenceQuaternion = new THREE.Quaternion().setFromEuler(
      new THREE.Euler(-Math.PI / 2, 0, 0, 'YXZ') // -90 degrees around X-axis
    );
  
    // Combine Device Quaternion with Reference Quaternion
    let finalQuaternion = deviceQuaternion.multiply(referenceQuaternion);
    finalQuaternion = finalQuaternion.invert()
    mesh.quaternion.copy(finalQuaternion)
  
    // Apply the final quaternion to the camera
    // mesh.quaternion.copy(finalQuaternion);
    // mesh.rotation.x += 0.02
    // mesh.rotation.y += 0.02
    // camera.quaternion.copy(finalQuaternion);
}




class LRTC{ //lopkn's boilerplate RTC

  static connectee(){
    this.type = "connectee"
    this.localConnection = new RTCPeerConnection()
 

    this.localConnection.onicecandidate = e =>  {
    console.log(" NEW ice candidate!! on localconnection reprinting SDP " )
     this.latestSDP = JSON.stringify(this.localConnection.localDescription)
     console.log(this.latestSDP)
    }


    this.sendChannel = this.localConnection.createDataChannel("sendChannel");
    this.sendChannel.onmessage = this.recieve
      this.sendChannel.onopen = e => console.log("open!!!!");
      this.sendChannel.onclose =e => console.log("closed!!!!!!");


    this.localConnection.createOffer().then(o => this.localConnection.setLocalDescription(o) )
  }

  static connecteeAnswer(answer){
    this.localConnection.setRemoteDescription(answer).then(a=>console.log("done"))
  }

  static async connector(offer){
    this.remoteConnection = new RTCPeerConnection()

    this.remoteConnection.onicecandidate = e =>  {
    console.log(" NEW ice candidnat!! on localconnection reprinting SDP ")
     this.latestSDP = JSON.stringify(this.remoteConnection.localDescription)
     console.log(this.latestSDP)
    }

     
    this.remoteConnection.ondatachannel= e => {

          this.receiveChannel = e.channel;
          this.receiveChannel.onmessage = this.recieve
          this.receiveChannel.onopen = e => console.log("open!!!!");
          this.receiveChannel.onclose =e => console.log("closed!!!!!!");
          this.remoteConnection.channel = this.receiveChannel;

    }


    this.remoteConnection.setRemoteDescription(offer).then(a=>console.log("done"))

    //create answer
    await this.remoteConnection.createAnswer().then(a => this.remoteConnection.setLocalDescription(a)).then(a=>
    console.log(JSON.stringify(this.remoteConnection.localDescription)))
  }


  static recieve(e){
    console.log("recieved: "+e.data)
    this.lastMessage = e
  }

  static send(e){
    if(this.type==="connectee"){
      this.sendChannel.send(e)
    } else {
      this.remoteConnection.channel.send(e)
    }
  }

}






function distance(x1,y1,x2,y2) {
    let a = x2-x1
    let b = y2-y1
  return(Math.sqrt(a*a+b*b))
}


var frameFuncs = []

function mainLoop(time){
  frameFuncs.forEach((e)=>{
    e(time)
  })
  requestAnimationFrame(mainLoop)
}

function oneTimeTrustedButton(f){
  let button = document.createElement("button")
  button.style.position = "absolute"
  button.style.backgroundColor = "purple"
  button.innerText = "one time verifier"
  button.style.top = button.style.left = "0px"

  button.style.zIndex = 5000
  button.addEventListener("click",(e)=>{f(e);button.remove()},{once:true})
  document.body.appendChild(button)
}


function Lvideo(type="screen",append=false){
    let video = document.createElement('video')
    video.id = "Lvideo-"+Math.random()
    video.setAttribute("autoplay","autoplay")
    if(append){
      document.body.append(video)
    }
    if(type=="screen"){
      oneTimeTrustedButton(async function() {let stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });video.srcObject = stream;})
    } else {
      oneTimeTrustedButton(async function() {let stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });video.srcObject = stream;})
    }
    return(video)
  }


//oneTimeTrustedButton(Lvideo)


function copyToCanvas(img,Lcan){
  Lcan.ctx.drawImage(img, 0, 0, Lcan.canvas.width, Lcan.canvas.height);
}

function setDefaultAbsolute(elm){
  elm.style.position = "absolute"
  elm.style.top = elm.style.left = "0px"
}




class Lcolorf{ //lopkn's color functions
  static dictify(arr){ //turns arrays of numbers into arrays of dicts
    let outarr = []
    for(let i = 0; i < arr.length; i+=4){
      outarr.push({"r":arr[0],"g":arr[1],"b":arr[2],"a":arr[3]})
    }
    return(outarr)
  }
  static colorDistA(arr1,arr2){//only works on Arrays of numbers //arr2 should be same length or shorter
    let dst = 0
    for(let i = 0; i < arr2.length; i++){
      dst += Math.abs(arr1[i]-arr2[i])
    }
    return(dst)
  }
}

class LPerceptron{ //it should have input name, input value. each input should have a multiplier towards a result
  constructor(){
    this.outputInputpair = {"testOutput":{"testInput":2}}
    this.inputs = {}
  }
  input(dict){
    this.inputs = dict
  }
  generateOutput(item){
    let result = 0
    item = this.outputInputpair[item]
    let objk = Object.keys(item)
    for(let i = 0; i < objk.length; i++){
      let inputting = objk[i]
      result += this.input[inputting] * item[inputting]
    }
    return(result)
  }
  learn(item,expected){
    item = this.outputInputpair[item]
    let objk = Object.keys(item)
    for(let i = 0; i < objk.length; i++){
      let inputting = objk[i]
      this.input[inputting] += item[inputting] * (expected?1:-1)
    }
  }
}

function normalRandom(mean, stderr, rng=world.rng) {
    const u1 = rng();
    const u2 = rng();

    const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
    return z0 * stderr + mean;
}

/* MUSIC/TONE

var scene = {
  "sounds":true,
  "interval":0.3,
  "beatsPerBar":4
}

function soundInit(){
    Tone.Transport.start();
    Tone.Transport.scheduleRepeat((time) => {
        music.runbar(time)
    }, scene.interval*scene.beatsPerBar)

    { let audio = new Tone.Sampler({
      urls: {
        "C4":"./../../soundEffects/sinC4.mp3",
        "F3":"./../../soundEffects/sinF3.mp3",
      },
    }).toDestination();
        SOUND["sinC4"] = audio

    }
      arr.forEach((E,i)=>{
        let e = "./../../soundEffects/"+E+".mp3"
        let audio = new Tone.Sampler({
      urls: {
        "C4":e,
      },
    }).toDestination();
        SOUND[E] = audio
      })
}

function mtn(midiNumber) {
    return Tone.Frequency(midiNumber, "midi");
}

class music{
  static counter = 0
  static synth = new Tone.PolySynth(Tone.Synth,8).toDestination(); // Connect to audio output
  static eq = new Tone.EQ3(-10, 3, 0);
  static reverb = new Tone.Reverb({
    decay: 20, // Duration of the reverb tail
    preDelay: 0.3,
    wet: 0.95,
    input:1,
    output:1
}).toDestination();
  static bell = new Tone.Sampler({
  urls: {
    "C4":"../epcounter/untitled.mp3",
  },
}).toDestination();
  static kick = new Tone.Sampler({
  urls: {
    "C4":"../epcounter/kick.mp3",
  },
}).toDestination();
  static click = new Tone.Sampler({
  urls: {
    "C4":"../epcounter/test.mp3",
  },
}).toDestination();
  static drumSynth = new Tone.MembraneSynth().toDestination();
  static echo = new Tone.PingPongDelay(scene.interval*2, scene.interval*2).toDestination();
  static playBell(note,vel=1,delay=0){
      this.bell.triggerAttackRelease(mtn(note),1.7,Tone.now()+delay,vel);
  }
  static playFile(file,note,vel=1,delay=0){
    this.sounds[file].triggerAttackRelease(mtn(note),1.7,Tone.now()+delay,vel);
  }

  static checkCollide(note,arr,dist=1){

    let mod = note%12
    for(let i = 0; i < arr.length; i++){
      let resd = Math.abs(arr[i]-mod)%12
      if(resd == dist || resd == 12-dist){
        return(true)
      }
    }
    return(false)
  }

  static checkCollider(note,dict,dist=1,oct=1){
    for(let i = 0; i < oct+1; i++){
      if(dict[note+dist+i*12] === true){return(true)}
      if(dict[note-dist+i*12] === true){return(true)}
      if(dict[note+dist-i*12] === true){return(true)}
      if(dict[note-dist-i*12] === true){return(true)}
    }
    return(false)
  }



}

music.bell.connect(music.reverb)
music.bell.connect(music.echo)
music.bell.connect(music.eq)
music.bell.set({volume:-20})
music.synth.set({
    oscillator: {
        type: 'sine4' 
    },
    envelope: {
        attack: 0.005,
        decay: 0.5,
        sustain:1,
        release:2
    },
    volume:-60
})
*/








function handleOrientation(event) {
  updateFieldIfNotNull('Orientation_a', event.alpha);
  updateFieldIfNotNull('Orientation_b', event.beta);
  updateFieldIfNotNull('Orientation_g', event.gamma);
  incrementEventCount();
}

function incrementEventCount(){
  // let counterElement = document.getElementById("num-observed-events")
  // let eventCount = parseInt(counterElement.innerHTML)
  // counterElement.innerHTML = eventCount + 1;
}


let vx, vy, vz;
vx = vy = vz = 0


function updateFieldIfNotNull(fieldName, value, precision=10){
  if (value != null)
    sensors[fieldName] = value.toFixed(precision);
}

function handleMotion(event) {
  updateFieldIfNotNull('Accelerometer_gx', event.accelerationIncludingGravity.x);
  updateFieldIfNotNull('Accelerometer_gy', event.accelerationIncludingGravity.y);
  updateFieldIfNotNull('Accelerometer_gz', event.accelerationIncludingGravity.z);

  // vx += parseFloat(event.acceleration.x)
  // vy += parseFloat(event.acceleration.y)
  // vz += parseFloat(event.acceleration.z)

  // vx *= 0.9
  // vy *= 0.99
  // vz *= 0.99


  // velocity = new THREE.Vector3(0, vy, 0)
  // localVelocity = velocity.clone().applyQuaternion(camera.quaternion);
  // camera.position.add(localVelocity.multiplyScalar(1))

  // camera.position.x += -vx
  // camera.position.y += vy
  // camera.position.z += vz

  updateFieldIfNotNull('Accelerometer_x', event.acceleration.x);
  updateFieldIfNotNull('Accelerometer_y', event.acceleration.y);
  updateFieldIfNotNull('Accelerometer_z', event.acceleration.z);

  updateFieldIfNotNull('Accelerometer_i', event.interval, 2);

  updateFieldIfNotNull('Gyroscope_z', event.rotationRate.alpha);
  updateFieldIfNotNull('Gyroscope_x', event.rotationRate.beta);
  updateFieldIfNotNull('Gyroscope_y', event.rotationRate.gamma);
  incrementEventCount();
}

// let is_running = false;
// let demo_button = document.getElementById("start_demo");
// oneTimeTrustedButton(function(e) {
//   e.preventDefault();
  
//   // Request permission for iOS 13+ devices
//   if (
//     DeviceMotionEvent &&
//     typeof DeviceMotionEvent.requestPermission === "function"
//   ) {
//     DeviceMotionEvent.requestPermission();
//   }
  
//   if (is_running){
//     window.removeEventListener("devicemotion", handleMotion);
//     window.removeEventListener("deviceorientation", handleOrientation);
//     // demo_button.innerHTML = "Start demo";
//     // demo_button.classList.add('btn-success');
//     // demo_button.classList.remove('btn-danger');
//     is_running = false;
//   }else{
//     window.addEventListener("devicemotion", handleMotion);
//     window.addEventListener("deviceorientation", handleOrientation);
//     // document.getElementById("start_demo").innerHTML = "Stop demo";
//     // demo_button.classList.remove('btn-success');
//     // demo_button.classList.add('btn-danger');
//     is_running = true;
//   }
// });







    document.addEventListener("keydown",(e)=>{
      if(e.repeat){return}

        if(e.key=="r"){
          // window.location.reload()
          DRONE.reset()
        } if(e.key == "R"){
          window.location.reload()
        } if(e.key == "1"){
          DRONE.rollControlSpeed *= 1.1
        } if(e.key == "2"){
          DRONE.rollControlSpeed *= 0.9
        } if(e.key == "i"){
          DRONE.invertedControls *= -1
        }
        if(e.key == "g"){
            scene.add(DRONE.topHemisphere)
            scene.add(DRONE.bottomHemisphere)
             // DRONE.topHemisphere.rotateY(Math.atan(1/2))
             // DRONE.bottomHemisphere.rotateY(Math.atan(1/2))
        }
        if(e.key == "G"){
          scene.remove(DRONE.topHemisphere)
            scene.remove(DRONE.bottomHemisphere)
             // DRONE.topHemisphere.rotateY(-Math.atan(1/2))
             // DRONE.bottomHemisphere.rotateY(-Math.atan(1/2))
        }

        if(e.key == "Enter"){
          camera.position.x += (world.loadeds[DRONE.worldPos].userData.end - camera.position.x) * 0.9
        }

        if(e.key == "p"){
          ENV.paused = !ENV.paused
        }


        if(e.key == "Tab"){
          e.preventDefault()
          // DRONE.vel.add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(200))
          DRONE.forwardLocked = !DRONE.forwardLocked
        }
      downs[e.key] = true
    })

    document.addEventListener("mousedown",(e)=>{
      downs["M"+e.button] = true
    })
    document.addEventListener("mouseup",(e)=>{
      downs["M"+e.button] = false
    })


    document.addEventListener("keyup",(e)=>{
      if(e.repeat){return}

      downs[e.key] = false
    })





    function test(){
      console.log("tri: " + renderer.info.render.triangles)
      console.log("drawcalls: " + renderer.info.render.calls)
    }
    window.test = test




    div.style.visibility = "hidden"
    </script>
  </body>
</html>

