<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3 Visualization</title>
    <script src="./d3.js"></script>

       <style>
        .tooltip {
            position: absolute;
            text-align: center;
            width: 60px;
            padding: 5px;
            font: 12px sans-serif;
            background: lightsteelblue;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
        }
    </style>
</head>


<textarea id="sqript" contenteditable=true style="overflow-y: scroll; background-color: rgba(0,125,0,0.2); position:absolute; top:0px; left:0px; width: 35%; height: 50%; color:organge; padding:2px"></textarea>


<body>
  <div class="tooltip" style="opacity: 0;"></div>
    <div id="chart"></div>

<script>

items = {}
linkers = []
vars = {}

function test1(){
  let s = `node uno
a:: testballs fattest
b:: causes nathan
a -> b
`
}

function test2(){
  let s = `
a ::testing test
b:: boys
d :: dogs

b -> dogs -> because
a -> b
boys -> a

a::b

`
  processStr(s)
}
function test3(){
  let s = `qrs
C1
C4
qrs -> C1
C1 -> cleaves -> C4
C4 -> into -> C4a
C4 -> into -> C4b
C4b -> binds -> C2a
C2a -> C2convertase
convertase cuts C3 -> C3a, C3b
C3b binds Convertase -> C5 convertase
C5convertase cuts C5 into a,b
C5b binds C6,78,9 -> membrane attack map`
let s2 = `qrs -> C1
C1 -> cleaves -> C4.
C4 -> into -> C4a.
C4 -> into -> C4b.
C4b -> binds -> C2a.
C2a -> C2 convertase
C2 convertase -> cuts -> C3.
C3 -> C3a
C3 -> C3b
C3b -> binds Convertase -> C5 convertase.
C5 convertase -> cuts -> C5.
C5 -> into ->  C5a.
C5 -> into -> C5b.
C5b -> binds -> C6,7,8,9.
C6,7,8,9 -> membrane attack map
`
}

class envs{
  static causality = "->"
  static definer = "::"
  static seperator = ","
  static declareGrammar = "."
}


function processStr(s){
  let spl = s.split("\n")
  spl.forEach((e)=>{
    processLine(e)
  })
}

function processLine(e){
    if(e.match(/^\s*$/)!==null){return}
    
    let causality = e.split(envs.causality)
    if(causality.length>1){
      causality.forEach((segment,i)=>{
        causality[i] = removeWhiteSpace(segment)
      })
    return(createLink(...causality))
    } // then there is only one word
    
   
    if(e.includes(envs.definer)){
       e = defineSyntax(e)
    } else {
      e = removeWhiteSpace(e)
      declareNode(e)
    }
    // return(declareNode(e))
}
  

function defineSyntax(e){
  let regex = new RegExp(`${envs.definer}(.+)$`)
  // let definition = e.match(/::(.+)$/) // fix?
  let definition = e.match(regex) // fix?
  //make definition
  let def = removeWhiteSpace(e.substring(0,e.length-definition[1].length-2))
  let fdef = removeWhiteSpace(definition[1])
  vars[def] = getNode(fdef)
  return(fdef)
}
  
function createLink(a,b,reason){

  if(reason!== undefined && reason[reason.length-1] === envs.declareGrammar){
    let r = b
    b = reason.slice(0,-1)
    reason = r
  }

  if(b.split(envs.seperator).length>1){
    b.split(envs.seperator).forEach((e)=>{
      createLink(a,e,reason)
    })
    return;
  }

  if(a.split(envs.seperator).length>1){
    a.split(envs.seperator).forEach((e)=>{
      createLink(e,b,reason)
    })
    return;
  }

  if(a.includes(envs.definer)){
    a = defineSyntax(a)
  }
  if(b.includes(envs.definer)){
    b = defineSyntax(b)
  }

  c = getNode(a)
  d = getNode(b)
  if(c !== a || d !== b){createLink(c,d,reason);return}


  let dict = {"f":a,"t":b} // from, to, reason
  linkers.push(dict)
  if(reason!==undefined){dict.r = reason}
  return(dict)
}
function getNode(x){
  if(vars[x]!==undefined){x = vars[x]}
    if(items[x]===undefined){
      declareNode(x)
    }
  return(x)
}
function declareNode(e,display=true){
  // console.log(`${e} declared`)

  if(e.includes(envs.seperator)){
    items[e] = {display:false,group:true}
    e.split(envs.seperator).forEach((e)=>{
      declareNode(e,display)
    })
    return
  }

  if(items[e]===undefined){
    items[e] = {display}
    if(vars[e]!==undefined){
      console.warn(`"${e}" was declared already declared as temp var`)
    }
  } else {
    console.warn(`"${e}" was already declared. Doing nothing.`)
  }
  return(items[e])
}

function removeWhiteSpace(str) {
    return str.replace(/^\s+|\s+$/g, '');
}

    </script>


    <script>



        
   
        document.addEventListener("keydown",(e)=>{
            if(e.key == "c"){
                // navigator.clipboard.writeText(JSON.stringify(ALG.dict))
            }
            if(e.key == "p"){
                (async()=>{
                    // let x = await navigator.clipboard.readText()
                    // console.log("loading new items")
                    // ALG.dict = JSON.parse(x)
                    // R();
                })()
                
            }

        })





        const data = {
            nodes: [
                { id: 'Node1', group: 1 },
                { id: 'Node2', group: 2 },
                { id: 'Node3', group: 2 },
                { id: 'Node4', group: 2 },
                { id: 'Node5', group: 2 },
                { id: 'Node6', group: 2 },
                // Add more nodes
            ],
            links: [
                // { source: 'Node1', target: 'Node2', value: 1 },
                { source: 'Node1', target: 'Node3', value: 1 },
                { source: 'Node1', target: 'Node3', value: 1 },
                { source: 'Node4', target: 'Node3', value: 2 },
                { source: 'Node5', target: 'Node3', value: 2 },
                { source: 'Node6', target: 'Node3', value: 4 },
                // Add more links
            ]
        };

        // let data = {nodes:[],links:[]}
        let ZOOM = 1
        const width = window.innerWidth;
        const height = window.innerHeight;
        const color = d3.scaleOrdinal(d3.schemeCategory10);
        var links = data.links.map(d => ({...d}));
        var nodes = data.nodes.map(d => ({...d}));


        let inputSpace = 100

        let idLoaded = {}

        document.getElementById('sqript').value = localStorage.getItem('savedContent') || ''
        window.onbeforeunload = function (e) {
          localStorage.setItem('savedContent', document.getElementById('sqript').value);
        };

        document.getElementById("sqript").addEventListener("keydown",(e)=>{
          if(e.key === "Enter"){
            reload()
          }if (event.key === 'Tab') {
                e.preventDefault(); // Prevent the default tab behavior
                let stringToInsert;
                if(e.shiftKey){
                  stringToInsert = env.definer+" "
                } else {
                  stringToInsert = " "+env.causality+" "
                }
                let textArea = document.getElementById("sqript")
                // Get the current cursor position
                const start = textArea.selectionStart;
                const end = textArea.selectionEnd;
                
                const textBefore = textArea.value.substring(0, start);
                const textAfter = textArea.value.substring(end);
                textArea.value = textBefore + stringToInsert + textAfter;
                
                // Move the cursor to the end of the inserted string
                textArea.selectionStart = textArea.selectionEnd = start + stringToInsert.length;
            }
        })







        var ANIMATE = true

        function start(){
          if(!ANIMATE){return}
            nodes = []
            links = []
            // RE()
        }
        // start()

        function R(){
            start();
            RE();
        }

        // function zm(){
        var stupidWorkaround;

        function reload(){
          let val = document.getElementById("sqript").value
            items = {}
            linkers = []
            vars = {}
            processStr(val)

            data.nodes = []
            data.links = []

            Object.keys(items).forEach((e)=>{if(!items[e].display){return};data.nodes.push({id:e,group:1})})
            linkers.forEach((e)=>{
              data.links.push({source:e.f,target:e.t,value:4,text:e.r})
            })
            if(e.shiftKey){
              e.preventDefault()
            }
            RE()
        }
        var zmev = (event) => {
          if(!event){return}
            stupidWorkaround = event
                    node.attr("transform", event.transform); // Apply zoom transformation
                    link.attr("transform", event.transform); // Apply zoom transformation
                    LINKTEXTS.attr("transform", event.transform); // Apply zoom transformation
                    ZOOM = event.transform.k
                    if(event.transform.k<1){
                      node.attr("r",Math.max(5/event.transform.k))
                      link.attr("stroke-width", d => Math.sqrt(d.value)/event.transform.k)
                    }
                }


        var zm = d3.zoom()
                .scaleExtent([0.01, 8]) // Set zoom limits
                .on("zoom", zmev)


        var simulation = d3.forceSimulation(data.nodes)
            .force("link", d3.forceLink(data.links).distance(d=>d.text?d.text.length*10+50:50).id(d => d.id).strength(1.5))
            .force("charge", d3.forceManyBody())
            // .force("center", d3.forceCenter(width / 2, height / 2))
            .on("tick", ticked);

        var svg = d3.create("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [0, 0, width, height])
            .attr("style", "max-width: 100%; height: auto;")
            .call(zm
            );
;

        svg.append("defs").append("marker")
        .attr("id", "arrowhead")
        .attr("viewBox", "0 0 10 10")
        .attr("refX", 15) // Position of the arrow
        .attr("refY", 5)
        .attr("orient", "auto")
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .append("polygon")
        .attr("points", "0 0, 10 5, 0 10")
        .attr("fill", "#999");


        var link = svg.append("g")
            .attr("stroke", "#999")
            .attr("stroke-opacity", 0.6)
            .selectAll()
            .data(data.links)
            .join("line")
            .attr("stroke-width", d => Math.sqrt(d.value))
            .attr("marker-end", "url(#arrowhead)");;


            const tooltip = d3.select(".tooltip");
        var node = svg.append("g").attr("stroke", "#fff")
        
        node = node.attr("stroke-width", 1.5)
            .selectAll("g")
            .data(data.nodes)
            .attr("class","dog")
            // .join("g")
            


        let dog = node
        node = node.join("circle")
            .attr("r", 5)
            .attr("fill", d => color(d.group))
            .on("mouseover", (event, d) => {
                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html(d.id /*+ "-" + 2*/)
                    .style("left", (event.pageX + 5) + "px")
                    .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", () => {
                tooltip.transition().duration(500).style("opacity", 0);
            })

            dog.join("text")
            // .text(d => "TESTTT").attr("stroke","#000")
            .style("pointer-events","none");


        node = svg.selectAll("circle, text")


        node.call(d3.drag()
            // .subject(d => ({x: x(d[0]), y: y(d[1])}))
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));


        var LINKTEXTS = svg.selectAll("text.link")

        function ticked() {
            link.attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);
       LINKTEXTS.attr("x", d => (d.source.x + d.target.x) / 2) // Position text in the middle
                .attr("y", d => (d.source.y + d.target.y) / 2)
                .attr("cx", d => (d.source.x + d.target.x) / 2) // Position text in the middle
                .attr("cy", d => (d.source.y + d.target.y) / 2);
            node.attr("cx", d => d.x)
                .attr("cy", d => d.y);
            node.attr("x", d => d.x)
                .attr("y", d => d.y);
        }



  function distance(x1,y1,x2,y2) {
  let a = x2-x1
  let b = y2-y1
  return(Math.sqrt(a*a+b*b))
}


        document.getElementById('chart').appendChild(svg.node());



      function addNodeAndLink(newNodeId, newNodeGroup, existingNodeId) {
        // Create a new node object
        const newNode = { id: newNodeId, group: newNodeGroup };
        data.nodes.push(newNode); // Add new node to nodes array

        // Create a new link object (linking to the existing node)
        const newLink = { source: existingNodeId, target: newNodeId, value: 1 };
        data.links.push(newLink); // Add new link to links array

        // Restart the simulation with the updated nodes and links
        simulation.nodes(data.nodes);
        simulation.force("link").links(data.links);
        simulation.alpha(1).restart(); // Restart the simulation

        // Update the SVG elements
        updateSVG();
    }

    function RE(){
      if(!ANIMATE){return}
        simulation.nodes(data.nodes);
        simulation.force("link").links(data.links);
        simulation.alpha(1).restart(); // Restart the simulation

        // Update the SVG elements
        updateSVG();
    }

    function updateSVG() {

      // Update links
        link = svg.selectAll("line")
            .data(data.links)
            .join("line")
            .attr("stroke-width", d => Math.sqrt(d.value))
            .attr("stroke", "#999")
            .attr("stroke-opacity", 0.6)
            .attr("marker-end", "url(#arrowhead)")
            .style("pointer-events", "none");;

              // Update nodes
        node = svg.selectAll("circle")
            .data(data.nodes)
            .join("circle")
            .attr("r", 5)
            .attr("fill", d => color(d.group))
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        // node.append("title").text(d => d.id+" INFO HERE MAY BE ADDED");

        
        // linkTextGroup = svg.append("g").attr("class", "link-text");
        LINKTEXTS = svg.selectAll("text.link")
        .data(data.links)
        .join("text")
        .attr("class","link")
        .attr("dy", ".35em") // Adjust vertical alignment
        .attr("text-anchor", "middle") // Center the text
        .text(d => d.text) // Set the text to d.text
        .style("fill", "#80F")
        .style("pointer-events","none")

        .attr("x", d => (d.source.x + d.target.x) / 2) // Position text in the middle
        .attr("y", d => {;return((d.source.y + d.target.y) / 2)});; // Position text in the middle


        // nodeTextGroup = svg.append("g").attr("class", "node-text")
        // debugger;

        dog = svg.selectAll("text.node")
            .data(data.nodes)
            .join("text")
            .attr("class","node")
            .text(d => d.id).attr("stroke","#000")
            .style("pointer-events","none");

        d3.selectAll("marker").lower()
        d3.selectAll("marker").lower()
        d3.selectAll("circle").raise()
        d3.selectAll("text").raise()

        node = svg.selectAll("circle, text.node")

        zmev(stupidWorkaround)


    }


  var start_x, start_y;  
  function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;

    start_x = +event.x;
    start_y = +event.y;
  }


  // Update the subject (dragged node) position during drag.
  function dragged(event) {
    event.subject.fx = start_x + ((event.x - start_x) / ZOOM);
    event.subject.fy = start_y + ((event.y - start_y) / ZOOM);
  }


  // Restore the target alpha so the simulation cools after dragging ends.
  // Unfix the subject position now that it’s no longer being dragged.
  function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
  }


    </script>
</body>
</html>