<!DOCTYPE html>
<html>
<meta charset="UTF-8">

<script src="https://cdn.jsdelivr.net/npm/three@0.143.0/build/three.js" onerror="alert('Error: Fetching 3JS')"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.143.0/examples/js/controls/OrbitControls.js" onerror="alert('Error: Fetching OrbitControls')"></script> 

<style>
html { height:100%; width:100%; }
body { margin:0; height:100%; width:100%; font-size:0 }
#cv { height:100%; width:100%; background: #777 }
#dat { position:absolute; top:4px;left:6px;width:400px; font-size:18px; color:#EEE; background:none; font-family:arial; font-weight:800; text-shadow: 2px 2px 4px #000; 
pointer-events: none; border:none;}
</style>
<body>
<input type=text id=dat autocomplete=off disabled>

<script>

const clock = new THREE.Clock();
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(36, window.innerWidth / window.innerHeight, 1, 100);
camera.position.set(4, 5, 4);

// LIGHTS
scene.add(new THREE.AmbientLight(0xffffff, 0.9));

const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(5, 10, 7.5);
dirLight.castShadow = true;
dirLight.shadow.camera.right = 2;
dirLight.shadow.camera.left = - 2;
dirLight.shadow.camera.top = 2;
dirLight.shadow.camera.bottom = - 2;
dirLight.shadow.mapSize.width = 1024;
dirLight.shadow.mapSize.height = 1024;
scene.add(dirLight);

// RENDERER
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.shadowMap.enabled = true;
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x453C67);
window.addEventListener('resize', onWindowResize);
document.body.appendChild(renderer.domElement);


// CONTROLS
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.minDistance = 2;
controls.maxDistance = 20;
controls.update();


init();
animate();


function addFace(objectGeom, objectColor, stencilRef, planePos, planeRot ) {

            // CUBE FACE
            const planeGeom = new THREE.PlaneGeometry();
            const stencilMat = new THREE.MeshPhongMaterial({ color: 'white' });
            stencilMat.depthWrite = false;
            stencilMat.stencilWrite = true;
            stencilMat.stencilRef = stencilRef;
            stencilMat.stencilFunc = THREE.AlwaysStencilFunc;
            stencilMat.stencilZPass = THREE.ReplaceStencilOp;
            const stencilMesh = new THREE.Mesh(planeGeom, stencilMat);
            stencilMesh.position.copy(planePos);
            stencilMesh.rotation.x = planeRot.x;
            stencilMesh.rotation.y = planeRot.y;
            stencilMesh.rotation.z = planeRot.z;
            stencilMesh.scale.multiplyScalar(0.9);
            scene.add(stencilMesh);
        
            // OBJECT INSIDE CUBE
            const objectMat = new THREE.MeshPhongMaterial({ color: objectColor});
            objectMat.stencilWrite = true;
            objectMat.stencilRef = stencilRef;
            objectMat.stencilFunc = THREE.EqualStencilFunc;
            const object = new THREE.Mesh(objectGeom, objectMat);
            scene.add(object);
    }

function outterObject(objectGeom, objectColor, objectPos){
	const objectMat = new THREE.MeshPhongMaterial({ color: objectColor});
    const object = new THREE.Mesh(objectGeom, objectMat);
    object.position.copy(objectPos);
    scene.add(object);

}

function init() {

    addFace(new THREE.ConeGeometry(0.25, 0.5, 4), 'red', 1, new THREE.Vector3(0,0,0.5), new THREE.Vector3(0,0,0));
    addFace(new THREE.ConeGeometry(0.35, 0.4, 4), 'blue', 4, new THREE.Vector3(0,0,-0.5), new THREE.Vector3( 0,0,0));


    outterObject(new THREE.ConeGeometry(0.25, 0.5, 4), 'red', new THREE.Vector3(1,0,0));
    outterObject(new THREE.ConeGeometry(0.35, 0.4, 4), 'blue', new THREE.Vector3(1,0,0));

}

function initPlanes () {
    const planeGeom = new THREE.PlaneGeometry();

    const stencilMat = new THREE.MeshPhongMaterial({ color: 'green' });
    stencilMat.colorWrite = false;
    stencilMat.depthWrite = false;
    stencilMat.stencilWrite = true;
    stencilMat.stencilRef = 1;
    stencilMat.stencilFunc = THREE.AlwaysStencilFunc;
    // stencilMat.stencilZFail = THREE.ReplaceStencilOp;
    // stencilMat.stencilFail = THREE.ReplaceStencilOp;
    stencilMat.stencilZPass = THREE.ReplaceStencilOp;
    const stencilMesh = new THREE.Mesh(planeGeom, stencilMat);
    const stencilHelper = new THREE.BoxHelper(stencilMesh, 'white');
    scene.add(stencilHelper);
    scene.add(stencilMesh);

    const blueMat = new THREE.MeshPhongMaterial({ color: 'blue' });
    blueMat.stencilWrite = true;
    blueMat.stencilRef = 1;
    blueMat.stencilFunc = THREE.NotEqualStencilFunc;
    const blueMesh = new THREE.Mesh(planeGeom, blueMat);
    blueMesh.position.x = -0.5;
    blueMesh.position.y = 0.5;
    scene.add(blueMesh);

    const redMat = new THREE.MeshPhongMaterial({ color: 'red' });
    redMat.stencilWrite = true;
    redMat.stencilRef = 1;
    redMat.stencilFunc = THREE.EqualStencilFunc;
    const redMesh = new THREE.Mesh(planeGeom, redMat);
    redMesh.position.x = 0.5;
    redMesh.position.y = -0.5;
    scene.add(redMesh);

}

function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);

}

function animate() {

    const delta = clock.getDelta();

    requestAnimationFrame(animate);

    renderer.render(scene, camera);

}
</script>
</body>
</html>
